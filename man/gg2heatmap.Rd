% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gg2heatmap.R
\name{gg2heatmap}
\alias{gg2heatmap}
\title{Creates a custom heatmap with dendrograms and annotations.}
\usage{
gg2heatmap(
  m,
  na.handle = "remove",
  dist.method = "manhattan",
  rank.fun = NULL,
  top.rows = NULL,
  dendrograms = TRUE,
  dend.size = 1,
  raster = NULL,
  facet = NULL,
  split.by.rows = NULL,
  plot.title = "",
  row.type = "rows",
  imputation.grps = NULL,
  ncores = 1,
  guide_custom_bar = ggplot2::guide_colorbar(title = "Values", barwidth = 15,
    ticks.linewidth = 1, title.vjust = 0.86),
  scale_fill_grad = ggplot2::scale_fill_gradientn(colors = c("steelblue", "gray95",
    "darkorange"), na.value = "black"),
  annot.grps = list(Groups = seq(ncol(m))),
  annot.pal = grDevices::rainbow(n = ncol(m)),
  theme_annot = NULL,
  annot.size = 1,
  annot.sep = 0,
  show.annot = TRUE,
  lgd.bars.name = "Legends",
  lgd.merge = FALSE,
  lgd.space.width = 1,
  lgd.space.height = 29,
  theme_legend = NULL,
  y.lab = "Values",
  x.lab = "Samples",
  theme_heatmap = NULL,
  border.col = NA,
  border.size = 0.1,
  cell.size = 1,
  y.axis.right = FALSE,
  draw = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{m}{A \code{matrix} with row and column names set, or a
molten \code{dataframe}:
\itemize{
 \item{Column 1 will be use for row names.}
 \item{Column 2 will be use for column names.}
 \item{Column 3 will be use for values.}
 \item{Additional columns coming after can be use for
 categorical splitting heatmap on rows with the
 'split.by.rows' option.}
}}

\item{na.handle}{A \code{character} to specify how missing values
should be handled.
\itemize{
 \item{'keep' do not modify the matrix}
 \item{'impute' make use of the groups provided in
       'imputation.grps' to calculate the mean value
       of a group of columns for a given row where at
       least one missing value has been found. The
       missing values are then substituted by the
       calculated mean of the group.}
 \item{'remove' removes all rows containing at least
       1 missing value.}
}
(Default: na.handle = 'remove';
Supported: na.handle = c('keep','impute','remove')).}

\item{dist.method}{A \code{character} vector to specify the distance
methods to be used on the matrix rows and columns.
\itemize{
 \item{If the vector is of length 1: the given method
       will be applied on rows and columns of the
       matrix.}
 \item{If the vector is of length 2: the first method
       will be applied on matrix rows, and the second
       method will be applied on matrix columns.}
}
(Default: dist.method = 'manhattan';
Supported: dist.method = c('euclidean', 'maximum',
'manhattan', 'canberra', 'binary', 'minkowski',
'none')).}

\item{rank.fun}{A \code{character} to specify a function to apply on
matrix rows to order them on the final heatmap. If
rank.fun = NULL the order of rows in the matrix will
be kept (Default: rank.fun = NULL;
Supported: rank.fun = 'sd').}

\item{top.rows}{An \code{integer} to specify the number of top rows
you want to display on the heatmap
(Default: top.rows = NULL).}

\item{dendrograms}{A \code{logical} vector to specify whether dendrograms
should be plotted with the heatmap.
\itemize{
 \item{If dendrograms = TRUE: both dendrograms on row
       and columns of the matrix will be plotted.}
 \item{If dendrograms = FALSE: both dendrograms on
       rows and columns of the matrix will NOT be
       plotted.}
 \item{If the vector is of length 2: the first logical
       will apply for rows, and the second logical
       will apply for columns.}
 \item{If 'rank.fun' and 'top.rows' are not NULL, and
       dendrograms on rows set to TRUE, the ranking of
       rows and the selection of the top ones will be
       made before the computation of dendrograms.}
}}

\item{dend.size}{A \code{numeric} vector defining row and column
dendrograms size (Default: dend.size = 1).
\itemize{
 \item{If dend.size is a \code{numeric}: the value is
       used to set both the width of the dendrogram
       built on rows, and the height of the dendrogram
       built on columns.}
 \item{If dend.size is a \code{numeric} vector of
       length 2: the first numeric will apply to the
       dendrogram built on rows, and the second
       numeric will apply to the dendrogram built on
       columns.}
}}

\item{raster}{A \code{character} to be used as a filter for matrix
rasterization. The list of the supported rasterization
filters is available in magick::filter_types(). If no
value is specified for 'raster' the original ggplot2
heatmap is displayed (Default: raster = NULL).
Warning: Be aware that rasterization may take several
more minutes than the usual process time.}

\item{facet}{A \code{character} matching an annotation name in
'annot.grps' to be used to split heatmap in separate
panels following the annotation.}

\item{split.by.rows}{A \code{character} matching one of the categorical
column in m if m is a molten data.frame to split
heatmap on rows. split.by.rows will not work if m is
matrix.}

\item{plot.title}{A \code{character} to be used as title for the plot.}

\item{row.type}{A \code{character} to be used in the plot subtitle
description as a definition of the rows (e.g. 'loci',
'samples', 'regions', etc.
Default: row.type = 'rows').}

\item{imputation.grps}{A \code{character} vector defining groups to which
columns of the matrix belong. These groups are use to
make group-wise imputation of missing values between
columns. The vector has to be of the same length than
the number of columns in the matrix
(Default: imputation.grps = NULL).}

\item{ncores}{An \code{integer} to specify the number of
cores/threads to be used to parallel-compute distances
for dendrograms.}

\item{guide_custom_bar}{A \code{guide} object generated by the ggplot2
function \link[ggplot2]{guide_colorbar} to custom the
heatmap color bar appearance
(see also 'scale_fill_grad' option).}

\item{scale_fill_grad}{A \code{ScaleContinous} object generated by ggplot2
functions such as \link[ggplot2]{scale_fill_gradient},
\link[ggplot2]{scale_fill_gradient2} or
\link[ggplot2]{scale_fill_gradientn} to customize
heatmap colors and the associated color bar.}

\item{annot.grps}{A \code{list} of vectors of groups to which variables
belongs for the annotation sidebars. Vectors' lengths
have to match the number of variables.}

\item{annot.pal}{A \code{vector} or a list of vectors containing colors
as characters for the annotation sidebars.The length
of vectors has to match the number of levels of
vectors listed in 'annot.grps'.
\itemize{
 \item{If annot.pal is a list: its length must match
       the length of the list provided to
       'annot.grps'.}
 \item{If annot.pal is a vector: make sure that the
       levels content of annotations listed in
       'annot.grps' is the same, and that no
       annotation contains less or more levels than
       another one in 'annot.grps'.}
}}

\item{theme_annot}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom on the annotation bar
(Default: theme_annot = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{annot.size}{A \code{numeric} defining the width of the annotation
bars (Default: annot.size = 1).}

\item{annot.sep}{A \code{numeric} vector specifying the width of the
separations between annotations
(Default: annot.sep = 0):
\itemize{
 \item{If annot.sep is a \code{numeric}: the value is
       used to set the width of both horizontal and
       vertical separations of annotations.}
 \item{If annot.sep is a \code{numeric} vector of
       length 2: the first numeric will apply to the
       width of horizontal separations, and the second
       numeric will apply to the
       width of vertical separations.}
}}

\item{show.annot}{A \code{logical} to specify whether annotations should
be displayed at the top of the heatmap
(show.annot = TRUE) or not (show.annot = FALSE).}

\item{lgd.bars.name}{A \code{character} specifying the name of annotation
side bar legends, when legends are merged
(lgd.merge = TRUE).
(Default: lgd.bars.name = 'Legends').}

\item{lgd.merge}{A \code{logical} specifying whether the legends of
multiple annotation bars should be merged
(lgd.merge = TRUE) or remain separated
(lgd.merge = FALSE). lgd.merge is especially useful
when you want to map the same color palette to
multiple annotations sharing the same values
(Default: lgd.merge = FALSE).}

\item{lgd.space.width}{A \code{numeric} specifying the width of the legend
space (Default: lgd.space.width = 1).}

\item{lgd.space.height}{An \code{integer} specifying the height of the legend
space (Default: lgd.space.height = 29).}

\item{theme_legend}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom on legends
(Default: theme_legend = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{y.lab}{A \code{character} to specify Y-axis title
(Default: y.lab = 'Values').}

\item{x.lab}{A \code{character} to specify X-axis title
(Default: x.lab = 'Samples').}

\item{theme_heatmap}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom on the heatmap part of the plot
(Default: theme_heatmap = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{border.col}{A \code{character} to specify an R color code for the
border delimitating the heatmap cells
(Default: border.col = NA).}

\item{border.size}{A \code{numeric} to specify the linewidth of cells
border (Default: border.size = 0.1).}

\item{cell.size}{A \code{numeric} vector of length 2 to specify the
width and height of cells taking values between 0 and
1.
\itemize{
 \item{If cell.size is a \code{numeric}: the value is
       used to set both the width and the height of
       cells.}
 \item{If cell.size is a \code{numeric} vector of
       length 2: the first numeric will apply to
       cell height, and the second numeric will apply
       to cell width.}
}}

\item{y.axis.right}{A \code{logical} to specify whether the heatmap Y axis
should be displayed on the right (y.axis.right = TRUE)
or not (y.axis.right = FALSE)
(Default: y.axis.right = FALSE).}

\item{draw}{A \code{logical} to specify whether the final heatmap
should be drawn automatically when gg2heatmap()
execution ends (draw = TRUE), or if it shouldn't
(draw = FALSE).}

\item{verbose}{A \code{logical} to display information about the
step-by-step processing of the data if TRUE
(Default: verbose = FALSE).}
}
\value{
A \code{grob} list containing the final plot, and also each grob
        generated separately.
}
\description{
Creates a custom heatmap with dendrograms and annotations.
}
\examples{
#Create the basic gg2heatmap
mat <- as.matrix(t(scale(mtcars)))
gg2heatmap(m = mat)
}
\author{
Yoann Pageaud.
}
