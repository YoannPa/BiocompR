% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggheatmap.R
\name{ggheatmap}
\alias{ggheatmap}
\title{Creates a custom heatmap with dendrograms and annotations.}
\usage{
ggheatmap(
  m,
  na.handle = "remove",
  dist.method = "manhattan",
  rank.fun = NULL,
  top.rows = NULL,
  dendrograms = TRUE,
  dend.size = 1,
  theme_dend_top = NULL,
  theme_dend_left = NULL,
  imputation.grps = NULL,
  ncores = 1,
  plot.labs = NULL,
  row.type = "rows",
  facet = NULL,
  split.by.rows = NULL,
  border.col = NA,
  border.size = 0.1,
  cell.size = 1,
  raster.filter = NULL,
  raster.size = 1080,
  theme_heatmap = NULL,
  guide_custom_bar = ggplot2::guide_colorbar(title = "Values", barwidth = 15,
    ticks.linewidth = 1, title.vjust = 0.86),
  scale_fill_grad = ggplot2::scale_fill_gradientn(colors = BiocompR::biopalette(name =
    "BiocompR_meth"), na.value = "black"),
  annot.grps = list(Groups = seq(ncol(m))),
  annot.pal = grDevices::rainbow(n = ncol(m)),
  annot.size = 1,
  annot.sep = 0,
  theme_annot = NULL,
  show.annot = TRUE,
  lgd.merge = FALSE,
  theme_legend = NULL,
  lgd.space.width = 1,
  lgd.space.height = 26,
  lgd.ncol = NULL,
  y.axis.right = FALSE,
  show.sub = TRUE,
  draw = TRUE,
  return_plots = "all",
  verbose = FALSE
)
}
\arguments{
\item{m}{A \code{matrix} with row and column names set, or a
molten \code{dataframe}:
\itemize{
 \item{Column 1 will be use for row names.}
 \item{Column 2 will be use for column names.}
 \item{Column 3 will be use for values.}
 \item{Additional columns coming after can be use for
 categorical splitting heatmap on rows with the
 'split.by.rows' option.}
}}

\item{na.handle}{A \code{character} to specify how missing values
should be handled.
\itemize{
 \item{'keep' do not modify the matrix}
 \item{'impute' make use of the groups provided in
       'imputation.grps' to calculate the mean value
       of a group of columns for a given row where at
       least one missing value has been found. The
       missing values are then substituted by the
       calculated mean of the group.}
 \item{'remove' removes all rows containing at least
       1 missing value.}
}
(Default: na.handle = 'remove';
Supported: na.handle = c('keep','impute','remove')).}

\item{dist.method}{A \code{character} vector to specify the distance
methods to be used on the matrix rows and columns.
\itemize{
 \item{If the vector is of length 1: the given method
       will be applied on rows and columns of the
       matrix.}
 \item{If the vector is of length 2: the first method
       will be applied on matrix rows, and the second
       method will be applied on matrix columns.}
}
(Default: dist.method = 'manhattan';
Supported: dist.method = c('euclidean', 'maximum',
'manhattan', 'canberra', 'binary', 'minkowski',
'none')).}

\item{rank.fun}{A \code{character} to specify a function to apply on
matrix rows to order them on the final heatmap.
Functions should be specified using the syntax
'package::function'. If rank.fun = NULL the order of
rows in the matrix will be kept
(Default: rank.fun = NULL;
Supported: rank.fun = 'stats::sd').}

\item{top.rows}{An \code{integer} to specify the number of top rows
you want to display on the heatmap
(Default: top.rows = NULL).}

\item{dendrograms}{A \code{logical} vector to specify whether dendrograms
should be plotted with the heatmap.
\itemize{
 \item{If dendrograms = TRUE: both dendrograms on row
       and columns of the matrix will be plotted.}
 \item{If dendrograms = FALSE: both dendrograms on
       rows and columns of the matrix will NOT be
       plotted.}
 \item{If the vector is of length 2: the first logical
       will apply for rows, and the second logical
       will apply for columns.}
 \item{If 'rank.fun' and 'top.rows' are not NULL, and
       dendrograms on rows set to TRUE, the ranking of
       rows and the selection of the top ones will be
       made before the computation of dendrograms.}
}}

\item{dend.size}{A \code{numeric} vector defining row and column
dendrograms size (Default: dend.size = 1).
\itemize{
 \item{If dend.size is a \code{numeric}: the value is
       used to set both the width of the dendrogram
       built on rows, and the height of the dendrogram
       built on columns.}
 \item{If dend.size is a \code{numeric} vector of
       length 2: the first numeric will apply to the
       dendrogram built on rows, and the second
       numeric will apply to the dendrogram built on
       columns.}
}}

\item{theme_dend_top}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom the top dendrogram
(Default: theme_dend = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{theme_dend_left}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom the left dendrogram
(Default: theme_dend = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{imputation.grps}{A \code{character} vector defining groups to which
columns of the matrix belong. These groups are use to
make group-wise imputation of missing values between
columns. The vector has to be of the same length than
the number of columns in the matrix
(Default: imputation.grps = NULL).}

\item{ncores}{An \code{integer} to specify the number of
cores/threads to be used to parallel-compute distances
for dendrograms.}

\item{plot.labs}{A \code{labels} ggplot2 object to pass labels to be
displayed on the final heatmap plot. Currently
'plot.labs' supports 4 different labels:
\itemize{
 \item{title - A \code{character} to be used as title
 for the plot.}
 \item{x - A \code{character} to specify X-axis title.
 }
 \item{y - A \code{character} to specify Y-axis title.
 }
 \item{legend - A \code{character} specifying the name
 of annotation side bar legends, when all legends are
 merged into a unique one (lgd.merge = TRUE).}
}
For more information on how to set labels for
'plot.labs' see \link[ggplot2]{labs}.}

\item{row.type}{A \code{character} to be used in the plot subtitle
description as a definition of the rows (e.g. 'loci',
'samples', 'regions', etc.
Default: row.type = 'rows').}

\item{facet}{A \code{character} matching an annotation name in
'annot.grps' to be used to split heatmap in separate
panels following the annotation.}

\item{split.by.rows}{A \code{character} matching one of the categorical
column in m if m is a molten data.frame to split
heatmap on rows. split.by.rows will not work if m is
matrix.}

\item{border.col}{A \code{character} to specify an R color code for the
border delimitating the heatmap cells
(Default: border.col = NA).}

\item{border.size}{A \code{numeric} to specify the linewidth of cells
border (Default: border.size = 0.1).}

\item{cell.size}{A \code{numeric} vector of length 2 to specify the
width and height of cells taking values between 0 and
1.
\itemize{
 \item{If cell.size is a \code{numeric}: the value is
       used to set both the width and the height of
       cells.}
 \item{If cell.size is a \code{numeric} vector of
       length 2: the first numeric will apply to
       cell height, and the second numeric will apply
       to cell width.}
}}

\item{raster.filter}{A \code{character} to be used as a filter for matrix
rasterization. The list of the supported rasterization
filters is available in magick::filter_types(). If no
value is specified for 'raster.filter' the original
ggplot2 heatmap is displayed
(Default: raster.filter = NULL).
Warning: Be aware that rasterization may take several
more minutes than the usual process time.}

\item{raster.size}{An \code{integer} specifying the size of a squared
raster in pixels. If raster.size = 1080 -> raster =
1080x1080 (Default: raster.size = 1080).}

\item{theme_heatmap}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom on the heatmap part of the plot
(Default: theme_heatmap = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{guide_custom_bar}{A \code{guide} object generated by the ggplot2
function \link[ggplot2]{guide_colorbar} to custom the
heatmap color bar appearance
(see also 'scale_fill_grad' option).}

\item{scale_fill_grad}{A \code{ScaleContinous} object generated by ggplot2
functions such as \link[ggplot2]{scale_fill_gradient},
\link[ggplot2]{scale_fill_gradient2} or
\link[ggplot2]{scale_fill_gradientn} to customize
heatmap colors and the associated color bar.}

\item{annot.grps}{A \code{list} of vectors of groups to which variables
belongs for the annotation sidebars. Vectors' lengths
have to match the number of variables.}

\item{annot.pal}{A \code{vector} or a list of vectors containing colors
as characters for the annotation sidebars.The length
of vectors has to match the number of levels of
vectors listed in 'annot.grps'.
\itemize{
 \item{If annot.pal is a list: its length must match
       the length of the list provided to
       'annot.grps'.}
 \item{If annot.pal is a vector: make sure that the
       levels content of annotations listed in
       'annot.grps' is the same, and that no
       annotation contains less or more levels than
       another one in 'annot.grps'.}
}}

\item{annot.size}{A \code{numeric} defining the width of the annotation
bars (Default: annot.size = 1).}

\item{annot.sep}{A \code{numeric} vector specifying the width of the
separations between annotations
(Default: annot.sep = 0):
\itemize{
 \item{If annot.sep is a \code{numeric}: the value is
       used to set the width of both horizontal and
       vertical separations of annotations.}
 \item{If annot.sep is a \code{numeric} vector of
       length 2: the first numeric will apply to the
       width of horizontal separations, and the second
       numeric will apply to the
       width of vertical separations.}
}}

\item{theme_annot}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom on the annotation bar
(Default: theme_annot = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{show.annot}{A \code{logical} to specify whether annotations should
be displayed at the top of the heatmap
(show.annot = TRUE) or not (show.annot = FALSE).}

\item{lgd.merge}{A \code{logical} specifying whether the legends of
multiple annotation bars should be merged
(lgd.merge = TRUE) or remain separated
(lgd.merge = FALSE). lgd.merge is especially useful
when you want to map the same color palette to
multiple annotations sharing the same values
(Default: lgd.merge = FALSE).}

\item{theme_legend}{A ggplot2 \code{theme} to specify any theme parameter
you wish to custom on legends
(Default: theme_legend = NULL). For more information
about how to define a theme, see
\link[ggplot2]{theme}.}

\item{lgd.space.width}{A \code{numeric} specifying the width of the legend
space (Default: lgd.space.width = 1).}

\item{lgd.space.height}{An \code{integer} specifying the height of the legend
space (Default: lgd.space.height = 29).}

\item{lgd.ncol}{An \code{integer} to override the internal legend
layout build, to specify the number of columns on
which legends'keys should be displayed
(Default: lgd.ncol = NULL).}

\item{y.axis.right}{A \code{logical} to specify whether the heatmap Y axis
should be displayed on the right (y.axis.right = TRUE)
or not (y.axis.right = FALSE)
(Default: y.axis.right = FALSE).}

\item{show.sub}{A \code{logical} to specify whether the subtitle
should be shown (Default: show.sub = TRUE) or not
(show.sub = FALSE).}

\item{draw}{A \code{logical} to specify whether the final heatmap
should be drawn automatically when ggheatmap()
execution ends (draw = TRUE), or if it shouldn't
(draw = FALSE).}

\item{return_plots}{A \code{character} specifying which plot objects
should be returned by ggheatmap().
\itemize{
 \item{return_plots = "all" (default) will return the
 heatmap plot, the grobs composing the heatmap, and
 the gg objects from which the grobs have been made.}
 \item{return_plots = "main" will only return the
 heatmap plot.}
}}

\item{verbose}{A \code{logical} to display information about the
step-by-step processing of the data if TRUE
(Default: verbose = FALSE).}
}
\value{
A \code{grob} list containing the final plot, and also each grob
        generated separately.
}
\description{
Creates a custom heatmap with dendrograms and annotations.
}
\examples{
# Create the basic ggheatmap
mat <- as.matrix(t(scale(mtcars)))
res <- ggheatmap(m = mat)
# Apply Euclidean distance on rows, and Manhattan distance on columns
res <- ggheatmap(m = mat, dist.method = c("euclidean", "manhattan"))
# Rank heatmap rows following their standard deviation
res <- ggheatmap(m = mat, dist.method = c("none", "manhattan"),
  rank.fun = "stats::sd", dendrograms = c(FALSE, TRUE))
# Keep top 5 rows with highest standard variation
res <- ggheatmap(m = mat, dist.method = c("none", "manhattan"),
  rank.fun = "stats::sd", dendrograms = c(FALSE, TRUE), top.rows = 5)
# Order rows and columns respectively by euclidean and manhattan distance,
# and hide both dendrograms
res <- ggheatmap(m = mat, dist.method = c("euclidean", "manhattan"),
  dendrograms = FALSE)
# Change both dendrograms size
res <- ggheatmap(m = mat, dist.method = c("euclidean", "manhattan"),
  dend.size = c(2, 5))
# Custom themes of top and left dendrograms
res <- ggheatmap(
  m = mat, theme_dend_top = ggplot2::theme(
    panel.background = ggplot2::element_rect(
      color = "red", linewidth = 1, fill = "lightblue")),
  theme_dend_left = ggplot2::theme(
      panel.background = ggplot2::element_rect(fill = "gold")))
# Set heatmap title, and X and Y axis titles
res <- ggheatmap(m = mat, plot.labs = labs(
  title = "mtcars example heatmap", x = "Cars", y = "Cars caracteristics"),
  y.axis.right = TRUE, # To enable the display of Y-axis on the right
  theme_heatmap = ggplot2::theme(
    axis.title.y.right = ggplot2::element_text(size = 14)))
# Specify what 'rows' correspond to in the subtitle.
res <- ggheatmap(m = mat, row.type = "caracteristics")
# Add 1 annotation for the top color bar
res <- ggheatmap(
  m = mat, annot.grps = list("Carb" = mtcars$carb),
  annot.pal = grDevices::rainbow(n = 6))
# Convert annotation as factor to order legend keys using levels
res <- ggheatmap(
  m = mat, annot.grps = list("Carb" = as.factor(mtcars$carb)),
  annot.pal = grDevices::rainbow(n = 6))
# Add more annotations as factor, adjust colorbar width, and justify legends
res <- ggheatmap(
  m = mat,
  annot.grps = list( #Separate annotations must all have different values
    "Carb" = as.factor(paste(mtcars$carb, "Carb")),
    "Gear" = as.factor(paste(mtcars$gear, "Gear")),
    "Am" = as.factor(paste(mtcars$am, "Am"))),
  annot.pal = list( #Palettes order must matches annotations order
    grDevices::rainbow(n = 6), c("pink", "red", "darkred"),
    c("grey", "blue")), annot.size = 3, # Increases top colorbar width
  theme_legend = ggplot2::theme(
    legend.justification = c(0, 0.8)), # Justifies all legends on the left
    lgd.space.height = 22) # Sets vertical space to avoid legends overlaps
# Facetting on 1 of the annotations
res <- ggheatmap(
  m = mat,
  annot.grps = list(
    "Carb" = as.factor(paste(mtcars$carb, "Carb")),
    "Gear" = as.factor(paste(mtcars$gear, "Gear")),
    "Am" = as.factor(paste(mtcars$am, "Am"))),
  annot.pal = list(
    grDevices::rainbow(n = 6), c("pink", "red", "darkred"),
    c("grey", "blue")),
    annot.size = 4, # Increases top colorbar width for facets strips
  theme_legend = ggplot2::theme(
    legend.justification = c(0, 0.8)), # Justifies all legends on the left
    lgd.space.height = 22,
  facet = "Carb", # Facetting heatmap using annotation 'Carb'
  dendrograms = FALSE, # Hide dendrogram since the facetting is On.
  dist.method = "none") # Disable clustering to let facetting work.
# Splitting on rows following a group annotation
molten.cars <- melt.data.table(
  data = as.data.table(mat, keep.rownames = TRUE), id.vars = "rn",
  variable.name = "cars")
molten.cars[
  rn \%in\% c('mpg', 'disp', 'hp', 'drat', 'qsec'), groups := "kinetic"]
molten.cars[
  rn \%in\% c('cyl', 'wt', 'vs', 'am', 'gear', 'carb'), groups := "mechanic"]
res <- ggheatmap(
  m = molten.cars, split.by.rows = "groups", # Splitting on rows by 'groups'
  dist.method = c('none', 'euclidean'), # Disable clustering on rows
  dendrograms = c(FALSE, TRUE), # Disable dendrogram display on rows
  lgd.space.width = 5, # Increase legend space
  theme_heatmap = ggplot2::theme(
    axis.text.y.left = element_text(size = 12), # Show Y labels on the left
    axis.ticks.y.left = element_line(linewidth = 0.5)), # Show Y ticks on left
  theme_legend = ggplot2::theme(legend.justification = c(0.5, 0.5))) # Center legend
# Custom heatmap cells borders color and width
res <- ggheatmap(m = mat, border.col = "black", border.size = 0.5)
# Custom heatmap cells height and width
res <- ggheatmap(m = mat, cell.size = c(0.9, 0.5))
# Plot a rastered heatmap using the Lanczos filter
res <- ggheatmap(m = mat, raster.filter = "Lanczos")
# Plot a rastered heatmap using the Lanczos filter changing the raster size
res <- ggheatmap(m = mat, raster.filter = "Lanczos", raster.size = 240)
# Plot a rastered faceted heatmap using the Lanczos filter
res <- ggheatmap(
  m = mat,
  annot.grps = list( # Annotations are not as factors in this example
    "Carb" = paste(mtcars$carb, "Carb"),
    "Gear" = paste(mtcars$gear, "Gear"),
    "Am" = paste(mtcars$am, "Am")),
  annot.pal = list(
    grDevices::rainbow(n = 6), c("pink", "red", "darkred"),
    c("blue", "grey")),
    annot.size = 4, # Increases top colorbar width for facets strips
  theme_legend = ggplot2::theme(
    legend.justification = c(0, 0.8)), # Justifies all legends on the left
  lgd.space.height = 22,
  facet = "Carb", # Facetting heatmap using annotation 'Carb'
  dendrograms = FALSE, # Hide dendrogram since the facetting is On
  dist.method = "none", # Disable clustering to let facetting work
  raster.filter = "Lanczos") # Rasterization using the Lanczos filter
# Custom the theme of the heatmap
res <- ggheatmap(
    m = mat,
    theme_heatmap = ggplot2::theme(
        panel.border = ggplot2::element_rect(
            color = "black", linewidth = 1,
            fill = "transparent"), # Add a border
        axis.text.y.right = ggplot2::element_text(
            size = 12), # Add right Y axis labels
        axis.ticks.y.right = ggplot2::element_line(
            color = "black"), # Add Y axis ticks
        axis.text.x = ggplot2::element_text(
            color = "red")), # Color X axis labels in red
    y.axis.right = TRUE) # Enable display of Y axis on the right side
# Custom the colorbar shape
res <- ggheatmap(m = mat, guide_custom_bar = guide_colorbar(
  title = "My custom colorbar", # Set colorbar title
  barwidth = 10, # Set colorbar width
  barheight = 0.5, # Set colorbar height
  ticks.linewidth = 4, # Set ticks width
  ticks.colour = "red", # Set ticks color
  title.vjust = 1, # Set vertical justification of colorbar title
  raster.filter = TRUE, # Rasterize colorbar
  nbin = 3, # Set the number of color bins in the colorbar
  frame.colour = "green", # Set colorbar frame color
  frame.linewidth = 2)) # Set colorbar frame linewidth
# Custom colorbar caracteristics using 'scale_fill_gradient'-like functions
res <- ggheatmap(m = mat, scale_fill_grad = ggplot2::scale_fill_gradientn(
    colors = BiocompR::biopalette(
        name = "BiocompR_meth2", mute = TRUE), # Set gradient
    na.value = "grey", # Set missing value color
    n.breaks = 10, # Set number of breaks
    labels = c("<=-1", seq(-0.8, 0.8, by = 0.2), ">= 1"), # Map custom labels
    limits = c(-1, 1), # Set limits for the colorbar
    oob = scales::squish)) # Squish values out of the bound of limits
# Custom vertical and horizontal separations width of annotations
res <- ggheatmap(m = mat, annot.grps = list(
    "Carb" = paste(mtcars$carb, "Carb"), "Gear" = paste(mtcars$gear, "Gear"),
    "Am" = paste(mtcars$am, "Am")), # Annotations are not as factors
    annot.pal = list(
        grDevices::rainbow(n = 6), c("pink", "red", "darkred"),
        c("blue", "grey")), annot.size = 3,
    theme_legend = ggplot2::theme(legend.justification = c(0, 0.8)),
    lgd.space.height = 22,
    annot.sep = c(0.3, 0.1)) # Horizontal space of 0.3, and vertical of 0.1
# Custom annotation theme
res <- ggheatmap(
    m = mat, annot.grps = list("Carb" = as.factor(mtcars$carb)),
    annot.pal = grDevices::rainbow(n = 6), theme_annot = ggplot2::theme(
        panel.border = ggplot2::element_rect(
            color = "black", # Set annotation border color to black
            linewidth = 1, # Set annotation border width to 1
            fill = "transparent"))) # Make annotation visible through rect.
# Override the internal legend layout build to specify the number of columns
# to display legends' keys (e.g. display legend keys on 4 columns)
res <- ggheatmap(m = mat, lgd.ncol = 4)
# Hide the annotation and annotation legends
res <- ggheatmap(m = mat, show.annot = FALSE)
# Merge annotations legends into a single legend
res <- ggheatmap(
    m = mat, annot.grps = list(
        "Carb" = as.factor(paste(mtcars$carb, "Carb")),
        "Gear" = as.factor(paste(mtcars$gear, "Gear")),
        "Am" = as.factor(paste(mtcars$am, "Am"))),
    annot.pal = list(
        grDevices::rainbow(n = 6), c("pink", "red", "darkred"),
        c("blue", "grey")), annot.size = 3,
    lgd.merge = TRUE) # Merge annotations legends into a single legend
# Custom legend theme
res <- ggheatmap(m = mat, theme_legend = ggplot2::theme(
    legend.background = ggplot2::element_rect(
        fill = "lightblue", # Add lightblue background
        color = "red"), # Add red border
    legend.key.size = ggplot2::unit(
        0.5, "lines"), # Decrease legend keys overall size
    legend.key.width = ggplot2::unit(
        1.4, "lines"), # Increase legend keys width
    legend.text = ggplot2::element_text(
        color = "red"))) # Color legend labels in red
# Increase legend space width on the left of the heatmap
res <- ggheatmap(m = mat, lgd.space.width = 3)
# Change legend space height
res <- ggheatmap(m = mat, lgd.space.height = 15)
# Hide the subtitle on the final heatmap
res <- ggheatmap(m = mat, show.sub = FALSE)
# Disable automatic drawing of the heatmap (to only retrieve grobs data)
res <- ggheatmap(m = mat, draw = FALSE)
# Access a specific gg object used to build the heatmap (e.g. a dendrogram)
res <- ggheatmap(m = mat, draw = FALSE)
res$ggplots$cols_dendrogram
# Return and access all grobs and gg objects used to build the heatmap
res <- ggheatmap(m = mat, draw = FALSE, return_plots = "all")
egg::ggarrange(plots = res$ggplots) # 'ggplots' contains all gg objects
gridExtra::grid.arrange( # 'legends' contains legends as grobs
    grobs = list(
        res$legends$heatmap_legends, res$legends$annotation_legends[[1]]),
    nrow = 1)
# Print step-by-step execution of ggheatmap (useful for debugging)
res <- ggheatmap(m = mat, verbose = TRUE)
}
\author{
Yoann Pageaud.
}
