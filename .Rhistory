as.character(melt(unique(data[, c(
"IDs", "remainings", "Subset"), ]), id.vars = "IDs")[
order(variable, decreasing = TRUE)]$value)
data[variable == "logremainings"]
data[variable == "logremainings", value.char := remainings]
data
data[variable == "logSubset", value.char := Subset]
data
#' Plots an annotated stacked barplot.
#'
#' @param data             A \code{data.table} containing:
#'                         \itemize{
#'                          \item{labels in column 1}
#'                          \item{total amounts in column 2}
#'                          \item{subset amounts in column 3}
#'                         }
#' @param round.unit       An \code{integer} to specify how many decimals should
#'                         be kept when rounding percentages
#'                         (Default: round.unit = 2).
#' @param rev.stack        A \code{logical} to specify whether the stacking
#'                         order of bars should be reversed or not
#'                         (Default: rev.stack = FALSE).
#' @param invert.percent   A \code{logical} to specify whether the calculated
#'                         percentage should reflect the share of the subset
#'                         initially defined in the data.table
#'                         (Default: invert.percent = FALSE), or should reflect
#'                         the remaining share of the total amount minus the
#'                         subset (invert.percent = TRUE).
#' @param horizontal       A \code{logical} to specify whether the plot should
#'                         be plotted horizontally or vertically
#'                         (Default: horizontal = FALSE).
#' @param log.scaled       A \code{logical} to specify whether the plot should
#'                         be log-scaled or not (Default: log.scaled = FALSE).
#' @param decreasing.order A \code{logical} to specify how the bars should be
#'                         ordered. By default, bars are ordered by increasing
#'                         order of the sum of the values they display. This
#'                         order can be inverted with: decreasing.order = TRUE.
#' @return A \code{gg} stacked barplot with annotations.
#' @author Yoann Pageaud.
#' @export
#TODO: Fix the way stacked bars are plotted
ggcoverage <- function(
data, round.unit = 2, rev.stack = FALSE, invert.percent = FALSE,
horizontal = FALSE, log.scaled = FALSE, decreasing.order = FALSE){
colnames(data)[1:3] <- c("IDs", "Total", "Subset")
#Replace NAs by zeros
data[is.na(Total), c("Total", "Subset") := 0]
data[is.na(Subset), Subset := 0]
#Calculate remaining amounts
data[, remainings := .(Total-Subset)]
if(invert.percent){
data[, percents := .(round((Subset/Total)*100, round.unit))]
} else {
data[, percents := .(round((remainings/Total)*100, round.unit))]
}
data[, percents := .(paste0(percents, "%"))]
if(log.scaled){
data[Subset == 0, Subset := 1]
# data[, c("logTotal", "logSubset") := .(log10(Total), log10(Subset))]
# data[, logremainings := .(logTotal-logSubset)]
data[, c("logTotal", "logremainings") := .(log10(Total), log10(remainings))]
data[, logSubset := .(logTotal-logremainings)]
data <- melt(data, id.vars = c(
"IDs", "Total", "Subset", "logTotal", "remainings", "percents"),
measure.vars = c("logSubset", "logremainings"))
} else {
data <- melt(data, id.vars = c("IDs", "Total", "percents"),
measure.vars = c("Subset", "remainings"))
}
if(!rev.stack){ #Change order for value before cumsum
data <- data[order(variable, decreasing = TRUE)]
}
data[, label_ypos := .(cumsum(value) - 0.5*value), by = IDs]
if(log.scaled){
# data[["value.char"]] <- as.character(melt(unique(data[, c(
#   "IDs", "remainings", "Subset"), ]), id.vars = "IDs")[
#     order(variable, decreasing = TRUE)]$value)
data[variable == "logremainings", value.char := remainings]
data[variable == "logSubset", value.char := Subset]
} else { data[, value.char := .(as.character(value))] }
#Set the orientation of interest
if (horizontal) {
display.count.cutoff <- 0.04
coeff.max.margin <- 0.1
} else {
display.count.cutoff <- 0.02
coeff.max.margin <- 0.05
}
if(log.scaled){
data$IDs <-
factor(data$IDs, levels = data[variable == "logremainings"][
order(Total, -value, IDs, decreasing = decreasing.order)]$IDs)
} else {
data$IDs <-
factor(data$IDs, levels = data[variable == "remainings"][
order(Total, -value, IDs, decreasing = decreasing.order)]$IDs)
}
if(rev.stack){
data$variable <- factor(data$variable, levels = rev(levels(data$variable)))
}
#Removing duplicated strings to not display it
data[, filter.val := .(value - display.count.cutoff*max(data$value))]
data[filter.val < 0, value.char := " "]
data[variable == "Subset", percents := " "]
if(log.scaled){ data[, "Total" := logTotal] }
#Barplot
ggcov <- ggplot(data = data, aes(x = IDs, y = value, fill = variable)) +
geom_bar(stat = "identity") +
geom_text(aes(y = label_ypos, label = value.char), vjust = 0.5,
color = "white", size = 4, fontface = "bold")
if (horizontal) {
ggcov <- ggcov +
geom_text(aes(y = Total, label = percents), hjust = -0.1) +
coord_flip()
} else {
ggcov <- ggcov +
geom_text(aes(y = Total, label = percents), vjust = -1, hjust = 0.5)
}
return(ggcov)
}
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = F)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T, rev.stack = T)
data = data_for_plotting
round.unit = 2
rev.stack = TRUE
invert.percent = FALSE
horizontal = FALSE
log.scaled = FALSE
decreasing.order = FALSE
log.scaled = TRUE
colnames(data)[1:3] <- c("IDs", "Total", "Subset")
#Replace NAs by zeros
data[is.na(Total), c("Total", "Subset") := 0]
data[is.na(Subset), Subset := 0]
#Calculate remaining amounts
data[, remainings := .(Total-Subset)]
if(invert.percent){
data[, percents := .(round((Subset/Total)*100, round.unit))]
} else {
data[, percents := .(round((remainings/Total)*100, round.unit))]
}
data[, percents := .(paste0(percents, "%"))]
log.scaled
data[Subset == 0, Subset := 1]
data[, c("logTotal", "logremainings") := .(log10(Total), log10(remainings))]
data
data = data_for_plotting
colnames(data)[1:3] <- c("IDs", "Total", "Subset")
#Replace NAs by zeros
data[is.na(Total), c("Total", "Subset") := 0]
data[is.na(Subset), Subset := 0]
#Calculate remaining amounts
data[, remainings := .(Total-Subset)]
if(invert.percent){
data[, percents := .(round((Subset/Total)*100, round.unit))]
} else {
data[, percents := .(round((remainings/Total)*100, round.unit))]
}
data[, percents := .(paste0(percents, "%"))]
data[Subset == 0, Subset := 1]
data[, c("logTotal", "logSubset") := .(log10(Total), log10(Subset))]
data
data[, logremainings := .(logTotal-logSubset)]
data
#' Plots an annotated stacked barplot.
#'
#' @param data             A \code{data.table} containing:
#'                         \itemize{
#'                          \item{labels in column 1}
#'                          \item{total amounts in column 2}
#'                          \item{subset amounts in column 3}
#'                         }
#' @param round.unit       An \code{integer} to specify how many decimals should
#'                         be kept when rounding percentages
#'                         (Default: round.unit = 2).
#' @param rev.stack        A \code{logical} to specify whether the stacking
#'                         order of bars should be reversed or not
#'                         (Default: rev.stack = FALSE).
#' @param invert.percent   A \code{logical} to specify whether the calculated
#'                         percentage should reflect the share of the subset
#'                         initially defined in the data.table
#'                         (Default: invert.percent = FALSE), or should reflect
#'                         the remaining share of the total amount minus the
#'                         subset (invert.percent = TRUE).
#' @param horizontal       A \code{logical} to specify whether the plot should
#'                         be plotted horizontally or vertically
#'                         (Default: horizontal = FALSE).
#' @param log.scaled       A \code{logical} to specify whether the plot should
#'                         be log-scaled or not (Default: log.scaled = FALSE).
#' @param decreasing.order A \code{logical} to specify how the bars should be
#'                         ordered. By default, bars are ordered by increasing
#'                         order of the sum of the values they display. This
#'                         order can be inverted with: decreasing.order = TRUE.
#' @return A \code{gg} stacked barplot with annotations.
#' @author Yoann Pageaud.
#' @export
#TODO: Fix the way stacked bars are plotted
ggcoverage <- function(
data, round.unit = 2, rev.stack = FALSE, invert.percent = FALSE,
horizontal = FALSE, log.scaled = FALSE, decreasing.order = FALSE){
colnames(data)[1:3] <- c("IDs", "Total", "Subset")
#Replace NAs by zeros
data[is.na(Total), c("Total", "Subset") := 0]
data[is.na(Subset), Subset := 0]
#Calculate remaining amounts
data[, remainings := .(Total-Subset)]
if(invert.percent){
data[, percents := .(round((Subset/Total)*100, round.unit))]
} else {
data[, percents := .(round((remainings/Total)*100, round.unit))]
}
data[, percents := .(paste0(percents, "%"))]
if(log.scaled){
data[Subset == 0, Subset := 1]
if(rev.stack){
data[, c("logTotal", "logSubset") := .(log10(Total), log10(Subset))]
data[, logremainings := .(logTotal-logSubset)]
} else {
data[, c("logTotal", "logremainings") := .(log10(Total), log10(remainings))]
data[, logSubset := .(logTotal-logremainings)]
}
data <- melt(data, id.vars = c(
"IDs", "Total", "Subset", "logTotal", "remainings", "percents"),
measure.vars = c("logSubset", "logremainings"))
} else {
data <- melt(data, id.vars = c("IDs", "Total", "percents"),
measure.vars = c("Subset", "remainings"))
}
if(!rev.stack){ #Change order for value before cumsum
data <- data[order(variable, decreasing = TRUE)]
}
data[, label_ypos := .(cumsum(value) - 0.5*value), by = IDs]
if(log.scaled){
# data[["value.char"]] <- as.character(melt(unique(data[, c(
#   "IDs", "remainings", "Subset"), ]), id.vars = "IDs")[
#     order(variable, decreasing = TRUE)]$value)
data[variable == "logremainings", value.char := remainings]
data[variable == "logSubset", value.char := Subset]
} else { data[, value.char := .(as.character(value))] }
#Set the orientation of interest
if (horizontal) {
display.count.cutoff <- 0.04
coeff.max.margin <- 0.1
} else {
display.count.cutoff <- 0.02
coeff.max.margin <- 0.05
}
if(log.scaled){
data$IDs <-
factor(data$IDs, levels = data[variable == "logremainings"][
order(Total, -value, IDs, decreasing = decreasing.order)]$IDs)
} else {
data$IDs <-
factor(data$IDs, levels = data[variable == "remainings"][
order(Total, -value, IDs, decreasing = decreasing.order)]$IDs)
}
if(rev.stack){
data$variable <- factor(data$variable, levels = rev(levels(data$variable)))
}
#Removing duplicated strings to not display it
data[, filter.val := .(value - display.count.cutoff*max(data$value))]
data[filter.val < 0, value.char := " "]
data[variable == "Subset", percents := " "]
if(log.scaled){ data[, "Total" := logTotal] }
#Barplot
ggcov <- ggplot(data = data, aes(x = IDs, y = value, fill = variable)) +
geom_bar(stat = "identity") +
geom_text(aes(y = label_ypos, label = value.char), vjust = 0.5,
color = "white", size = 4, fontface = "bold")
if (horizontal) {
ggcov <- ggcov +
geom_text(aes(y = Total, label = percents), hjust = -0.1) +
coord_flip()
} else {
ggcov <- ggcov +
geom_text(aes(y = Total, label = percents), vjust = -1, hjust = 0.5)
}
return(ggcov)
}
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = F)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = F, rev.stack = T)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T, rev.stack = F)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T, rev.stack = T)
exp(100)
10^-2
log10(100)
10^2
10^1.5
10^0.5
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T, rev.stack = F)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T, rev.stack = F, invert.percent = T)
data_for_plotting <- as.data.table(data.frame(col1 = c("C", "B", "A", "D", "E"), col2 = 100:104, col3 = 35:39))
ggcoverage(data_for_plotting, log.scaled = T, rev.stack = T, invert.percent = T)
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
##IMPORTS
library(data.table)
setwd("/icgc/dkfzlsdf/analysis/G200/pageaud/PhD/Plass_Lab/Hematopoiesis_DNMT1_Hypomorph")
setwd("/run/user/1000/gvfs/sftp:host=odcf-worker01/icgc/dkfzlsdf/analysis/G200/pageaud/PhD/Plass_Lab/Hematopoiesis_DNMT1_Hypomorph")
source("analysis/DMRs_Methylation_Metrics/get_regions_methylation_metrics.R")
dir.MC <- "data/NEW_MC_DATA/DML_Filtr_Merged_MethylationCalling_P-val005/"
sample.ids <- list.files(dir.MC)[-13]
sample.ids
list.files(dir.MC)[-13]
list.files(dir.MC)
list.files(dir.MC)[-11]
sample.ids <- list.files(dir.MC)[-11]
chroms <- as.character(1:19)
regions <- extract_bed(file = "DMRs/New_Data_17-12-2018/hspc-dmrs_v1.tsv")
regions
library(data.table)
setwd("/run/user/1000/gvfs/sftp:host=odcf-worker01/icgc/dkfzlsdf/analysis/G200/pageaud/PhD/Plass_Lab/Hematopoiesis_DNMT1_Hypomorph")
source("analysis/DMRs_Methylation_Metrics/get_regions_methylation_metrics.R")
##PARAMETERS
#Directory containing the methylation calls of all samples
# (one subdirectory per sample).
dir.MC <- "data/NEW_MC_DATA/DML_Filtr_Merged_MethylationCalling_P-val005/"
#Samples
sample.ids <- list.files(dir.MC)[-11]
#Supported chromosomes
chroms <- as.character(1:19)
##ANALYSIS
##Get Methylation Metrics on HSPC DMRs Regions
#Extract genomic regions from file
regions <- extract_bed(file = "DMRs/New_Data_17-12-2018/hspc-dmrs_v1.tsv")
#Saving Directory for Matrix of average methylation
# Save.Mat.Av.Meth.Dir <- "data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS"
Save.Mat.Av.Meth.Dir <- "data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEWbis.RDS"
#Saving Directory for the list of Metrics
# Save.Metrics.Dir<-"data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEW.RDS"
Save.Metrics.Dir <- "data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEWbis.RDS"
#Get regions methylation metrics
list.regions.metrics <- list()
res <- get.regions.methylation.metrics(
dir.MC = dir.MC, regions.df = regions, sample.ids = sample.ids,
autosomes = chroms, CGcov.cutoff = 0, CGcount.cutoff = 3,
regioncov.cutoff = 30, region.min.percentile = 0.2,
list.regions.metrics = list.regions.metrics, ncores = 20, verbose = T)
#Extract Regions Average Methylation
Regions.Av.Methylation <- lsdf.val2mat(list.res = res, val.name = "Av.Meth")
res$hsc
OLD <- readRDS("data/data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS")
OLD <- readRDS("data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS")
OLD[,1]
colnames(OLD)
head(res$hsc$Av.Meth)
head(OLD[,1])
head(res$hsc$Av.Meth, n=50)
head(res$`hsc_mu-chip-mut`, n=50)
head(res$`hsc_mu-chip-mut`$Av.Meth, n=50)
head(res$`hsc_mu-chip-mut`$Av.Meth, n=100)
head(res$`hsc_mu-chip-mut`$Av.Meth, n=500)
Regions.Av.Methylation
head(Regions.Av.Methylation)
head(Regions.Av.Methylation[,1])
head(Regions.Av.Methylation[,1], n=50)
head(Regions.Av.Methylation[,1], n=20)
head(res$hsc$Av.Meth, n= 20)
Regions.Av.Methylation
dim(Regions.Av.Methylation)
dim(OLD)
all.equal(target = Regions.Av.Methylation, current = OLD)
Save.Mat.Av.Meth.Dir <- "data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS"
DT_HSPC_DMRS <- rbindlist(res, idcol = TRUE)
DT_HSPC_DMRS <- DT_HSPC_DMRS[, c(".id", "Av.Meth", "Av.Cov", "SD.Cov",
"Cumul.Cov", "Number.CpGs"), with = FALSE]
DT_HSPC_DMRS
OLD <- readRDS("data/DT_HSPC_DMRS.RDS")
all.equal(target = OLD, current = DT_HSPC_DMRS)
OLD <- readRDS("data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEW.RDS")
all.equal(target = OLD, current = res)
##IMPORTS
library(data.table)
setwd("/run/user/1000/gvfs/sftp:host=odcf-worker01/icgc/dkfzlsdf/analysis/G200/pageaud/PhD/Plass_Lab/Hematopoiesis_DNMT1_Hypomorph")
source("analysis/DMRs_Methylation_Metrics/get_regions_methylation_metrics.R")
##PARAMETERS
#Directory containing the methylation calls of all samples
# (one subdirectory per sample).
dir.MC <- "data/NEW_MC_DATA/DML_Filtr_Merged_MethylationCalling_P-val005/"
#Samples
sample.ids <- list.files(dir.MC)[-11]
#Supported chromosomes
chroms <- as.character(1:19)
##ANALYSIS
##Get Methylation Metrics on HSPC DMRs Regions
#Extract genomic regions from file
regions <- extract_bed(file = "DMRs/New_Data_17-12-2018/hspc-dmrs_v1.tsv")
#Saving Directory for Matrix of average methylation
Save.Mat.Av.Meth.Dir <- "data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS"
#Saving Directory for the list of Metrics
# Save.Metrics.Dir<-"data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEW.RDS"
Save.Metrics.Dir <- "data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEWbis.RDS"
#Saving Directory for the list of Metrics
Save.Metrics.Dir<-"data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEW.RDS"
##Get Methylation Metrics on Full Hierarchy DMRS Regions
#Extract genomic regions from file
regions <- extract_bed(file = "DMRs/New_Data_17-12-2018/full-hierarchy-dmrs_v2.tsv")
#Saving Directory for Matrix of average methylation
Save.Mat.Av.Meth.Dir <- "data/DML_Filt_Merged_FullHier_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEWbis.RDS"
#Saving Directory for the list of Metrics
Save.Metrics.Dir <- "data/DML_Filt_Merged_FullHier_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEWbis.RDS"
list.regions.metrics <- list()
res<- get.regions.methylation.metrics(
dir.MC = dir.MC, regions.df = regions, sample.ids = sample.ids,
autosomes = chroms, CGcov.cutoff = 0, CGcount.cutoff = 3,
regioncov.cutoff = 30, region.min.percentile = 0.2,
list.regions.metrics = list.regions.metrics, ncores = 7, verbose = T)
#Extract Regions Average Methylation
Regions.Av.Methylation <- lsdf.val2mat(list.res = res, val.name = "Av.Meth")
head(Regions.Av.Methylation)
newbis<-readRDS("DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEW.RDS")
newbis<-readRDS("data/DML_Filt_Merged_FullHier_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEWbis.RDS")
all.equal(target = newbis, current = Regions.Av.Methylation)
new<-readRDS("data/DML_Filt_Merged_FullHier_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS")
all.equal(target = new, current = Regions.Av.Methylation)
newbis.stat<-readRDS("data/DML_Filt_Merged_FullHier_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEWbis.RDS")
all.equal(target = newbis.stat, current = res)
newbis.stat
newbis.stat$hsc
colnames(newbis.stat$hsc)
colnames(res$hsc)
all.equal(target = newbis.stat$hsc, current = res$hsc)
all.equal(target = newbis.stat$`hsc_mu-chip-mut`, current = res$`hsc_mu-chip-mut`)
all.equal(target = newbis.stat$`hsc_mu-chip-wt_1`, current = res$`hsc_mu-chip-wt_1`)
all.equal(target = newbis.stat, current = res)
##IMPORTS
library(data.table)
setwd("/run/user/1000/gvfs/sftp:host=odcf-worker01/icgc/dkfzlsdf/analysis/G200/pageaud/PhD/Plass_Lab/Hematopoiesis_DNMT1_Hypomorph")
source("analysis/DMRs_Methylation_Metrics/get_regions_methylation_metrics.R")
##PARAMETERS
#Directory containing the methylation calls of all samples
# (one subdirectory per sample).
dir.MC <- "data/NEW_MC_DATA/DML_Filtr_Merged_MethylationCalling_P-val005/"
#Samples
sample.ids <- list.files(dir.MC)[-11]
#Supported chromosomes
chroms <- as.character(1:19)
##ANALYSIS
##Get Methylation Metrics on HSPC DMRs Regions
#Extract genomic regions from file
regions <- extract_bed(file = "DMRs/New_Data_17-12-2018/hspc-dmrs_v1.tsv")
#Saving Directory for Matrix of average methylation
Save.Mat.Av.Meth.Dir <- "data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS"
#Saving Directory for the list of Metrics
Save.Metrics.Dir<-"data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEW.RDS"
#Get regions methylation metrics
list.regions.metrics <- list()
res <- get.regions.methylation.metrics(
dir.MC = dir.MC, regions.df = regions, sample.ids = sample.ids,
autosomes = chroms, CGcov.cutoff = 0, CGcount.cutoff = 3,
regioncov.cutoff = 30, region.min.percentile = 0.2,
list.regions.metrics = list.regions.metrics, ncores = 7, verbose = T)
#Extract Regions Average Methylation
Regions.Av.Methylation <- lsdf.val2mat(list.res = res, val.name = "Av.Meth")
#Save Matrix of Average Methylation
con <- gzfile(Save.Mat.Av.Meth.Dir, "wb", compression = 9L)
saveRDS(Regions.Av.Methylation, con)
close(con)
#Extract Regions Average Methylation and Coverage as data.table
DT_HSPC_DMRS <- rbindlist(res, idcol = TRUE)
DT_HSPC_DMRS <- DT_HSPC_DMRS[, c(".id", "Av.Meth", "Av.Cov", "SD.Cov",
"Cumul.Cov", "Number.CpGs"), with = FALSE]
saveRDS(DT_HSPC_DMRS, "data/DT_HSPC_DMRS.RDS")
#Save List of metrics; Metrics can be used for regions future selection...
saveRDS(res, Save.Metrics.Dir)
##Get Methylation Metrics on Full Hierarchy DMRS Regions
#Extract genomic regions from file
regions <- extract_bed(file = "DMRs/New_Data_17-12-2018/full-hierarchy-dmrs_v2.tsv")
#Saving Directory for Matrix of average methylation
Save.Mat.Av.Meth.Dir <- "data/DML_Filt_Merged_FullHier_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005_NEW.RDS"
#Saving Directory for the list of Metrics
Save.Metrics.Dir <- "data/DML_Filt_Merged_FullHier_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_STAT_NEW.RDS"
#Get regions methylation metrics
list.regions.metrics <- list()
res<- get.regions.methylation.metrics(
dir.MC = dir.MC, regions.df = regions, sample.ids = sample.ids,
autosomes = chroms, CGcov.cutoff = 0, CGcount.cutoff = 3,
regioncov.cutoff = 30, region.min.percentile = 0.2,
list.regions.metrics = list.regions.metrics, ncores = 7, verbose = T)
#Extract Regions Average Methylation
Regions.Av.Methylation <- lsdf.val2mat(list.res = res, val.name = "Av.Meth")
#Save Matrix of Average Methylation
con <- gzfile(Save.Mat.Av.Meth.Dir, "wb", compression = 9L)
saveRDS(Regions.Av.Methylation, con)
close(con)
rbindlist(res, idcol = TRUE)
DT_FullHier_DMRS <- rbindlist(res, idcol = TRUE)
DT_FullHier_DMRS[, c(".id", "Av.Meth", "Av.Cov", "SD.Cov",
"Cumul.Cov", "Number.CpGs"),
with = FALSE]
Regions.Av.Methylation
DT_FullHier_DMRS <- DT_FullHier_DMRS[, c(".id", "Av.Meth", "Av.Cov", "SD.Cov",
"Cumul.Cov", "Number.CpGs"),
with = FALSE]
saveRDS(DT_FullHier_DMRS, "data/DT_FullHier_DMRS.RDS")
saveRDS(res, Save.Metrics.Dir)
