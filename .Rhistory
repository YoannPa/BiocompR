rank.method<-c("sd")
if(!is.null(rank.fun)){
if(!rank.fun %in% rank.method){ stop("ranking function not supported.") }
}
#Check if top.rows is an integer
if(!is.null(top.rows)){
if(is.numeric(top.rows)){
top.rows <- as.integer(top.rows)
if(top.rows <1){ stop("'top.rows' must be a non-zero positive integer.") }
} else { stop("'top.rows' must be a non-zero positive integer.") }
}
#Check logicals for dendrograms
if(length(dendrograms) == 1){
dd.rows<-dendrograms
dd.cols<-dendrograms
} else if(length(dendrograms) == 2){
dd.rows<-dendrograms[1]
dd.cols<-dendrograms[2]
} else { stop("'dendrograms' length > 2. Too many values.") }
#Check annotations groups and palettes matching
check.annotations(data = m, annot.grps = annot.grps, annot.pal = annot.pal)
data = m
method = na.handle
groups = imputation.grps
ncores = ncores
data <- data[
!unlist(mclapply(X = seq(nrow(data)), mc.cores = ncores,
FUN = function(r){
all(is.na(data[r,])) })), , drop = FALSE]
#Get groups of samples from sample conditions
grp_tbl<-data.frame(samples = colnames(data), groups = groups)
sample_grps<-unique(groups)
#Get median by groups
#TODO: Make parallel apply when it will be possible.
lapply(X = seq(nrow(data)), FUN = function(r){
invisible(sapply(sample_grps, function(grp){
#List sample names matching the group
samples.in.grp<-grp_tbl[groups == grp,]$samples
#List Methylation values of the group on the row
if(all(is.na(data[r,samples.in.grp]))){
#TODO: Handle this case if the issue arises.
stop("The group as NA for all its values.")
} else if(anyNA(data[r,samples.in.grp])){
data[r,samples.in.grp][is.na(data[r,samples.in.grp])] <<-
median(x = data[r,samples.in.grp], na.rm = TRUE)
}
}))
})
head(data)
head(data,n=500)
##Imports
setwd("/run/user/1000/gvfs/sftp:host=odcf-worker01/icgc/dkfzlsdf/analysis/G200/pageaud/PhD/Plass_Lab/Hematopoiesis_DNMT1_Hypomorph/")
Imports = c("ggsci","RColorBrewer")
invisible(lapply(Imports, library, character.only = T))
source("analysis/Heatmaps_Plot/manage_na.R")
source("analysis/CORE_FUN/core_ggplot_fun.R")
source("analysis/Heatmaps_Plot/gg2heatmap.R")
##Parameters
#Load Matrix (ALL)
m<-readRDS('data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005.RDS')
#Specify which samples to display
# samples.selected<-seq(ncol(m)) #Load Full Matrix
# samples.selected<-c(1,2,4,5,7,8,10,11,13,15) #Load Matrix (Mut & Normal)
# samples.selected<-c(2,3,5,6,8,9,11,12,14,16) #Load Matrix (Mut & WT)
samples.selected<-c(1,3,4,6,7,9,10,12:16) #Load Matrix (Normal & WT)
##NEW SCRIPT####################################################################
##_Extract Cell types and Genotypes_############################################
sample_tbl<-data.table("Samples"= colnames(m))
#Get cell types/lines
sample_tbl[, samples_split:=.(strsplit(Samples, split="_"))]
sample_tbl[, Cell.types:=.(sapply(samples_split, head, n=1))]
#Get genotypes
sample_tbl[, Genotypes:=.(
sapply(sapply(samples_split, head, n=2), paste0, collapse = " "))]
sample_tbl[!grepl("chip", Genotypes, ignore.case=FALSE), Genotypes:="C57BL_6J"]
sample_tbl[
grepl("wt", Genotypes, ignore.case=FALSE), Genotypes:="129P2_OlaHsd_WT"]
sample_tbl[
grepl("mut", Genotypes, ignore.case=FALSE), Genotypes:="129P2_OlaHsd_Mut"]
sample_tbl[, Geno.short:=.(sapply(sapply(Genotypes, strsplit, "_"), tail, 1))]
sample_tbl[grepl("6J", Geno.short, ignore.case=FALSE), Geno.short:="Normal"]
#Set samples conditions
sample_tbl[, Sample.cond:=.(paste(Cell.types, Genotypes, sep ="_"))]
#Format Sample Table
sample_tbl<-sample_tbl[, .(
Genotypes,Geno.short,Cell.types,Samples,Sample.cond,Order=seq(ncol(m)))]
##_Create genotype-color table_#################################################
#Genotype Legend Order
# legend.genotype.order<-c(2,3,1)
legend.genotype.order<-c(1,2,3)
#Select the ggsci palette of your choice with
# palette.genotypes<-pal_npg("nrc",alpha = 1)(10)[c(1,2,3)] # Nature Reviews Cancer
palette.genotypes<-pal_npg("nrc",alpha = 1)(10)[c(3,1,2)] # Nature Reviews Cancer
#Initialize table
color_tbl<-data.table(
"Genotypes" = unique(sample_tbl$Geno.short)[legend.genotype.order],
"Colors" = palette.genotypes, stringsAsFactors = FALSE)
#Subset samples from table
subset.smpl<-colnames(m)[samples.selected]
#Update color table
color_tbl<-color_tbl[
Genotypes %in% unique(sample_tbl[Samples%in%subset.smpl]$Geno.short)]
#Subset sample table by the samples selected
sample_tbl<-sample_tbl[Order %in% samples.selected,]
#Subset Matrix with selected samples
m<-m[,samples.selected]
#Select Palette for values
# palette.heatmap<-c("steelblue", "gray95", "darkorange") #Default palette
palette.heatmap<-rev(brewer.pal(n = 11,name = "RdBu"))
m = m
na.handle = 'impute'
dist.method = 'manhattan'
rank.fun = NULL
top.rows = NULL
dendrograms = TRUE
imputation.grps = sample_tbl$Cell.types
ncores = 7
heatmap.pal = palette.heatmap
annot.grps = list("Genotypes" = sample_tbl$Geno.short,
"Cell.types" = sample_tbl$Cell.types)
annot.pal = list(pal_npg("nrc", alpha = 1)(10)[c(3,2)],
pal_nejm("default", alpha = 1)(8)[c(1:6)])
annot.size = 2
annot.split = FALSE
lgd.merge = FALSE
if(!is.matrix(m)){ stop("m must be a matrix.") }
#Check if na.handle method  supported
na.method <- c('keep','impute','remove')
if(!na.handle %in% na.method){ stop("na.handle method not supported.") }
#Check dimensions of parameters
if(length(dist.method) == 1){
method.rows<-dist.method
method.cols<-dist.method
} else if(length(dist.method) == 2){
method.rows<-dist.method[1]
method.cols<-dist.method[2]
} else { stop("'dist.method' length > 2. Too many values.") }
#Check distance methods
methods.ls <- c(
'euclidean','maximum','manhattan','canberra','binary','minkowski','none')
if(!method.rows %in% methods.ls){
stop("Unknown method for distance computation on rows.")
}
if(!method.cols %in% methods.ls){
stop("Unknown method for distance computation on columns.")
}
#Check if rank.fun is a supported function
rank.method<-c("sd")
if(!is.null(rank.fun)){
if(!rank.fun %in% rank.method){ stop("ranking function not supported.") }
}
#Check if top.rows is an integer
if(!is.null(top.rows)){
if(is.numeric(top.rows)){
top.rows <- as.integer(top.rows)
if(top.rows <1){ stop("'top.rows' must be a non-zero positive integer.") }
} else { stop("'top.rows' must be a non-zero positive integer.") }
}
#Check logicals for dendrograms
if(length(dendrograms) == 1){
dd.rows<-dendrograms
dd.cols<-dendrograms
} else if(length(dendrograms) == 2){
dd.rows<-dendrograms[1]
dd.cols<-dendrograms[2]
} else { stop("'dendrograms' length > 2. Too many values.") }
#Check annotations groups and palettes matching
check.annotations(data = m, annot.grps = annot.grps, annot.pal = annot.pal)
#Handle NAs
m<-manage.na(data = m, method = na.handle, groups = imputation.grps,
ncores = ncores)
head(m)
head(m, n = 500)
gg2heatmap(m = m, na.handle = 'impute', dist.method=c('euclidean','manhattan'),
rank.fun = NULL, top.rows = NULL, dendrograms = TRUE,
imputation.grps = sample_tbl$Cell.types, ncores = 7,
heatmap.pal = palette.heatmap,
annot.grps = list("Genotypes" = sample_tbl$Geno.short,
"Cell.types" = sample_tbl$Cell.types),
annot.pal = list(pal_npg("nrc", alpha = 1)(10)[c(3,2)],
pal_nejm("default", alpha = 1)(8)[c(1:6)]),
annot.size = 2, annot.split = FALSE, lgd.merge = FALSE)
##Imports
setwd("/run/user/1000/gvfs/sftp:host=odcf-worker01/icgc/dkfzlsdf/analysis/G200/pageaud/PhD/Plass_Lab/Hematopoiesis_DNMT1_Hypomorph/")
Imports = c("ggsci","RColorBrewer")
invisible(lapply(Imports, library, character.only = T))
source("analysis/Heatmaps_Plot/manage_na.R")
source("analysis/CORE_FUN/core_ggplot_fun.R")
source("analysis/Heatmaps_Plot/gg2heatmap.R")
##Parameters
#Load Matrix (ALL)
m<-readRDS('data/DML_Filt_Merged_HSPC_DMRs_NoSNPs_DMRCov30_Dens3_DMRpercent02_P-val005.RDS')
#Specify which samples to display
# samples.selected<-seq(ncol(m)) #Load Full Matrix
# samples.selected<-c(1,2,4,5,7,8,10,11,13,15) #Load Matrix (Mut & Normal)
# samples.selected<-c(2,3,5,6,8,9,11,12,14,16) #Load Matrix (Mut & WT)
samples.selected<-c(1,3,4,6,7,9,10,12:16) #Load Matrix (Normal & WT)
##NEW SCRIPT####################################################################
##_Extract Cell types and Genotypes_############################################
sample_tbl<-data.table("Samples"= colnames(m))
#Get cell types/lines
sample_tbl[, samples_split:=.(strsplit(Samples, split="_"))]
sample_tbl[, Cell.types:=.(sapply(samples_split, head, n=1))]
#Get genotypes
sample_tbl[, Genotypes:=.(
sapply(sapply(samples_split, head, n=2), paste0, collapse = " "))]
sample_tbl[!grepl("chip", Genotypes, ignore.case=FALSE), Genotypes:="C57BL_6J"]
sample_tbl[
grepl("wt", Genotypes, ignore.case=FALSE), Genotypes:="129P2_OlaHsd_WT"]
sample_tbl[
grepl("mut", Genotypes, ignore.case=FALSE), Genotypes:="129P2_OlaHsd_Mut"]
sample_tbl[, Geno.short:=.(sapply(sapply(Genotypes, strsplit, "_"), tail, 1))]
sample_tbl[grepl("6J", Geno.short, ignore.case=FALSE), Geno.short:="Normal"]
#Set samples conditions
sample_tbl[, Sample.cond:=.(paste(Cell.types, Genotypes, sep ="_"))]
#Format Sample Table
sample_tbl<-sample_tbl[, .(
Genotypes,Geno.short,Cell.types,Samples,Sample.cond,Order=seq(ncol(m)))]
##_Create genotype-color table_#################################################
#Genotype Legend Order
# legend.genotype.order<-c(2,3,1)
legend.genotype.order<-c(1,2,3)
#Select the ggsci palette of your choice with
# palette.genotypes<-pal_npg("nrc",alpha = 1)(10)[c(1,2,3)] # Nature Reviews Cancer
palette.genotypes<-pal_npg("nrc",alpha = 1)(10)[c(3,1,2)] # Nature Reviews Cancer
#Initialize table
color_tbl<-data.table(
"Genotypes" = unique(sample_tbl$Geno.short)[legend.genotype.order],
"Colors" = palette.genotypes, stringsAsFactors = FALSE)
#Subset samples from table
subset.smpl<-colnames(m)[samples.selected]
#Update color table
color_tbl<-color_tbl[
Genotypes %in% unique(sample_tbl[Samples%in%subset.smpl]$Geno.short)]
#Subset sample table by the samples selected
sample_tbl<-sample_tbl[Order %in% samples.selected,]
#Subset Matrix with selected samples
m<-m[,samples.selected]
#Select Palette for values
# palette.heatmap<-c("steelblue", "gray95", "darkorange") #Default palette
palette.heatmap<-rev(brewer.pal(n = 11,name = "RdBu"))
gg2heatmap(m = m, na.handle = 'impute', dist.method=c('euclidean','manhattan'),
rank.fun = NULL, top.rows = NULL, dendrograms = TRUE,
imputation.grps = sample_tbl$Cell.types, ncores = 7,
heatmap.pal = palette.heatmap,
annot.grps = list("Genotypes" = sample_tbl$Geno.short,
"Cell.types" = sample_tbl$Cell.types),
annot.pal = list(pal_npg("nrc", alpha = 1)(10)[c(3,2)],
pal_nejm("default", alpha = 1)(8)[c(1:6)]),
annot.size = 2, annot.split = FALSE, lgd.merge = FALSE)
#TODO: Support rank.fun alone
#TODO: Support top.rows alone
#TODO: Add some data in return
gg2heatmap<-function(m, na.handle = 'remove', dist.method = 'manhattan',
rank.fun = NULL, top.rows = NULL, dendrograms = TRUE,
imputation.grps = NULL, ncores = 1,
heatmap.pal = c("steelblue", "gray95", "darkorange"),
annot.grps = list("Groups" = seq(ncol(m))),
annot.pal = rainbow(n = ncol(m)), annot.size=1,
annot.lgd.space = 0, annot.split = FALSE,
lgd.lab = 'Legends', lgd.pos.x = 0.5, lgd.pos.y = 0.5,
lgd.merge = FALSE){
#Check m is a matrix
if(!is.matrix(m)){ stop("m must be a matrix.") }
#Check if na.handle method  supported
na.method <- c('keep','impute','remove')
if(!na.handle %in% na.method){ stop("na.handle method not supported.") }
#Check dimensions of parameters
if(length(dist.method) == 1){
method.rows<-dist.method
method.cols<-dist.method
} else if(length(dist.method) == 2){
method.rows<-dist.method[1]
method.cols<-dist.method[2]
} else { stop("'dist.method' length > 2. Too many values.") }
#Check distance methods
methods.ls <- c(
'euclidean','maximum','manhattan','canberra','binary','minkowski','none')
if(!method.rows %in% methods.ls){
stop("Unknown method for distance computation on rows.")
}
if(!method.cols %in% methods.ls){
stop("Unknown method for distance computation on columns.")
}
#Check if rank.fun is a supported function
rank.method<-c("sd")
if(!is.null(rank.fun)){
if(!rank.fun %in% rank.method){ stop("ranking function not supported.") }
}
#Check if top.rows is an integer
if(!is.null(top.rows)){
if(is.numeric(top.rows)){
top.rows <- as.integer(top.rows)
if(top.rows <1){ stop("'top.rows' must be a non-zero positive integer.") }
} else { stop("'top.rows' must be a non-zero positive integer.") }
}
#Check logicals for dendrograms
if(length(dendrograms) == 1){
dd.rows<-dendrograms
dd.cols<-dendrograms
} else if(length(dendrograms) == 2){
dd.rows<-dendrograms[1]
dd.cols<-dendrograms[2]
} else { stop("'dendrograms' length > 2. Too many values.") }
#Check annotations groups and palettes matching
check.annotations(data = m, annot.grps = annot.grps, annot.pal = annot.pal)
#Handle NAs
m<-manage.na(data = m, method = na.handle, groups = imputation.grps,
ncores = ncores)
#Apply ranking function if any function defined
if(!is.null(rank.fun)){#TODO: improve this part to support more function
m <- m[order(apply(m, 1, sd, na.rm = T), decreasing = TRUE), , drop = FALSE]
}
#Subset top rows if any value defined
if(!is.null(top.rows)){
m <- head(x = m, n = top.rows)
}
#Remove NAs if some for dendrogram matrix
dend_mat<- m[complete.cases(m),]
#Create Dendrograms
if(dd.rows & method.rows != 'none'){
#Create Rows Dendrogram
row_dist<-parDist(dend_mat, method = method.rows, threads = ncores)
row_hclust<-hclust(row_dist)
rm(row_dist)
rowclust<-as.dendrogram(row_hclust)
#Get dendrogram segments and order matrix rows
ddgr_seg_row <- ggdend(df = dendro_data(rowclust)$segments,
orientation = "left", plot.type = 'heatmap')
row.order<-order.dendrogram(rowclust)
} else if(dd.rows & method.rows == 'none'){
stop("Cannot plot rows dendrogram with method.rows = 'none'.")
}
if(dd.cols & method.cols != 'none'){
#Create Columns Dendrogram
ddgr <- as.dendrogram(hclust(
parDist(t(dend_mat), method = method.cols, threads = ncores)))
#Get dendrogram data
ddgr_dat<-dendro_data(ddgr)
#Get dendrogram segments and order matrix columns
ddgr_seg_col <- ggdend(
df = ddgr_dat$segments, orientation = "top", plot.type = 'heatmap')
column.order<-order.dendrogram(ddgr)
} else if(dd.cols & method.cols == 'none'){
stop("Cannot plot columns dendrogram with method.cols = 'none'.")
}
#Reorder rows and columns matrix following dendrograms orders
if(dd.rows & method.rows != 'none' & dd.cols & method.cols != 'none'){
dframe <- m[row.order, column.order, drop = FALSE]
} else if(dd.rows & method.rows != 'none' & is.null(rank.fun) & !dd.cols){
dframe <- m[row.order, , drop = FALSE]
} else if(!dd.rows & dd.cols & method.cols != 'none'){
dframe <- m[, column.order, drop = FALSE]
}
melted_mat <- melt(dframe) #Melt Matrix into a dataframe
colnames(melted_mat)[3]<-"Methylation"
#Plot Heatmap
htmp <-ggplot() +
geom_tile(data = melted_mat, aes(x = Var2, y = Var1, fill=Methylation)) +
scale_fill_gradientn(colours = palette.heatmap) +
scale_x_discrete(expand = c(0,0)) + scale_y_discrete(expand = c(0,0)) +
theme(legend.justification = 'left', plot.margin = margin(0, 0, 0, 0),
legend.position = c(0.5,0.5), panel.grid = element_blank(),
panel.background = element_rect(fill = "transparent"),
plot.background = element_rect(fill = "transparent"))
if(dendrograms[1]){
htmp <- htmp +
theme(axis.title.y = element_blank(),
axis.ticks.y = element_blank(),
axis.ticks.length.y = unit(0, "pt"),
axis.text.y = element_blank(),
plot.margin=unit(c(0,0,0,0),"cm"))
}
htmp <- htmp +
theme(legend.text=element_text(size= 11),
legend.title = element_text(size = 12),
axis.title.x = element_text(size = 12, color = "black"),
axis.text.x = element_text(size = 11, angle = -45, hjust = 0,
vjust = 0.5, face = "bold")) +
xlab("Samples")
#Reoder groups and convert as factors
annot.grps <- lapply(X = annot.grps, FUN = function(i){
factor(x = i, levels =  unique(i))})
annot.grps <- lapply(X = annot.grps, FUN = function(i){i[column.order]})
#Create Color Sidebar
col_sidebar<-plot.col.sidebar(
sample.names = colnames(m[, column.order]), annot.grps = annot.grps,
annot.pal = annot.pal, annot.pos = 'top',
cor.order = seq_along(colnames(dframe)), split.annot = annot.split,
merge.lgd = lgd.merge, right = TRUE, lgd.lab = lgd.lab,
axis.text.x = element_blank(),
axis.text.y = element_text(size = 11, color = "black"),
axis.ticks.y = element_blank(), axis.ticks.x = element_blank(),
axis.title.x = element_blank(), axis.title.y = element_blank(),
set.x.title = NULL, set.y.title = NULL, dendro.pos = 'top')
#Extract Legend
htmp_legend <- get.lgd(gg2.obj = htmp)
sidebar_legend <- col_sidebar$legends
#Convert ggplots into grobs
ddgr_seg_col <- ggplotGrob(ddgr_seg_col)
col_sidebar_grob <- ggplotGrob(col_sidebar$sidebar)
ddgr_seg_row <- ggplotGrob(ddgr_seg_row)
htmp <- ggplotGrob(htmp + theme(legend.position="none"))
#Resize grobs
upd.grob_w<-resize.grobs(ls.grobs = list(
'dd_col' = ddgr_seg_col, 'sidebar' = col_sidebar_grob, 'htmp' = htmp),
dimensions = "widths", start.unit = 4, end.unit = 7)
upd.grob_h<- resize.grobs(ls.grobs = list(
'dd_row' = ddgr_seg_row, 'htmp' = upd.grob_w$htmp), dimensions = 'heights',
start.unit = 7, end.unit = 9)
#Combine Dendrogram with Color Sidebar and Heatmap
if((length(dendrograms) == 1 & dendrograms) |
(length(dendrograms) == 2 & all(dendrograms == TRUE))){
#Create main grob
main_grob <- arrangeGrob(
grobs = list(textGrob(""), upd.grob_w$dd_col,
textGrob(""), upd.grob_w$sidebar,
upd.grob_h$dd_row, upd.grob_h$htmp),
ncol = 2, nrow = 3, heights = c(3, annot.size, 30), widths = c(2, 10))
#Create the Right Panel for legends
sidebar_legend.grob <- arrangeGrob(
grobs = sidebar_legend, nrow = 4, heights = c(4,1+annot.lgd.space,4,4))
right.legends <- arrangeGrob(
htmp_legend, textGrob(""), sidebar_legend.grob,
layout_matrix = cbind(c(1,1,1,2), c(2,2,2,2), c(3,3,3,3)),
vp = viewport(x= lgd.pos.x-0.6, y = lgd.pos.y))
# right.legends <- arrangeGrob(
#   textGrob(""), textGrob(""), textGrob(""),
#   htmp_legend, textGrob(""), sidebar_legend.grob,
#   textGrob(""), textGrob(""), textGrob(""),
#   ncol = 3, vp = viewport(x = -0.1), widths = c(1,1,1),
#   heights = c(1, 1 + annot.lgd.space, 1 + annot.lgd.space))
#Final plot
grid.arrange(arrangeGrob(
top = textGrob("DMRs in 129 and BL6J WT Vs. 129 Mut DMNT1 HSPCs",
gp = gpar(fontsize = 15, font = 1)),
grobs = list(
textGrob(paste("(Columns ordered by", method.cols,
"distance; Rows ordered by", method.rows, "distance;",
nrow(m), "loci.)"), gp = gpar(fontsize=12, fontface=3L)),
arrangeGrob(grobs = list(main_grob, right.legends), ncol = 2,
widths = c(20,3))),
nrow = 2, heights = c(3,50)))
}
}
library(rray)
install.packages("bigstatsr")
devtools::document()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
devtools::document()
devtools::install()
library(BiocompR)
devtools::document()
devtools::install()
library(BiocompR)
df.complete2 = data.frame(
Samples=rep(paste0("Sample",c(1:6)),each = 1000),
Groups=rep(c('A','B','C'),each = 2000),
Conditions=rep(c('I','J'),each = 1000,3),
Values=c(rnorm(1000,0), rnorm(1000, 0.5),
rnorm(1000, 3), rnorm(1000, 3.5),
rnorm(1000,-3), rnorm(1000, -3.5)),
Scnd.Var = rep(rep(x =c(60,50,40,30,20,10,30,40,50,60),
each=100),6))
ggcraviola(data = df.complete2, lines.col = "black", bins = TRUE)
ggcraviola(data = df.complete2, lines.col = "black", bins = TRUE) +
labs(alpha = "SD(2nd Variable)") +
ggtitle("This is a Craviola plot!") +
theme(plot.title = element_text(hjust = 0.5),
axis.text = element_text(size = 14, color = "black"),
axis.title = element_text(size = 15),
legend.title = element_text(size = 13),
legend.text = element_text(size = 12),
panel.background = element_blank(),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_line(color = "grey"),
panel.grid.minor.y = element_line(color = "grey")) +
scale_y_continuous(expand = c(0,0)) +
scale_fill_manual(labels = c("Control","Case"),
values = c("dodgerblue","darkorange"))
