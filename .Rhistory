axis.title.x = element_text(size = 12, color = 'black'),
axis.text.x = element_text(
size = 11, angle = -45, hjust = 0, vjust = 0.5, face = 'bold'),
axis.ticks.x = element_line(color = 'black'), y.axis.right = FALSE,
axis.title.y.right = element_blank(), axis.text.y.right = element_blank(),
axis.ticks.y.right = element_blank(), axis.title.y.left = element_blank(),
axis.text.y.left = element_blank(), axis.ticks.y.left = element_blank(),
verbose = FALSE){
#Check m is a matrix
if(!is.matrix(m)){ stop("m must be a matrix.") }
#Check if na.handle method  supported
na.method <- c('keep', 'impute', 'remove')
if(!na.handle %in% na.method){ stop("na.handle method not supported.") }
#Check dimensions of parameters
if(length(dist.method) == 1){
method.rows <- dist.method
method.cols <- dist.method
} else if(length(dist.method) == 2){
method.rows <- dist.method[1]
method.cols <- dist.method[2]
} else { stop("'dist.method' length > 2. Too many values.") }
#Check distance methods
methods.ls <- c('euclidean', 'maximum', 'manhattan', 'canberra',
'binary', 'minkowski', 'none')
if(!method.rows %in% methods.ls){
stop("Unknown method for distance computation on rows.")
}
if(!method.cols %in% methods.ls){
stop("Unknown method for distance computation on columns.")
}
#Check if rank.fun is a supported function
rank.method <- c("sd")
if(!is.null(rank.fun)){
if(!rank.fun %in% rank.method){ stop("ranking function not supported.") }
}
#Check if top.rows is an integer
if(!is.null(top.rows)){
if(is.numeric(top.rows)){
top.rows <- as.integer(top.rows)
if(top.rows <1){ stop("'top.rows' must be a non-zero positive integer.") }
} else { stop("'top.rows' must be a non-zero positive integer.") }
}
#Check logicals for dendrograms
if(length(dendrograms) == 1){
dd.rows <- dendrograms
dd.cols <- dendrograms
} else if(length(dendrograms) == 2){
dd.rows <- dendrograms[1]
dd.cols <- dendrograms[2]
} else { stop("'dendrograms' length > 2. Too many values.") }
#Check dendrogram sizes
if(length(dend.size) == 1){
dend.row.size <- dend.size
dend.col.size <- dend.size
} else if(length(dend.size) == 2){
dend.row.size <- dend.size[1]
dend.col.size <- dend.size[2]
} else { stop("'dend.size' length > 2. Too many values.") }
#Check annotation separation widths
if(length(annot.sep) == 1){
annot.cut <- annot.sep
annot.sep <- annot.sep
} else if(length(annot.sep) == 2){
annot.cut <- annot.sep[2]
annot.sep <- annot.sep[1]
} else { stop("'annot.sep' length > 2. Too many values.") }
#Check if y.axis.right = TRUE when axis.text.y.right or axis.title.y.right or
# axis.ticks.y.right are not element_blank()
if((!is.elt_blank(axis.text.y.right) | !is.elt_blank(axis.title.y.right) |
!is.elt_blank(axis.ticks.y.right)) & !y.axis.right){
warning(
paste("'y.axis.right' has to be set to TRUE in order to display the",
"Y-axis on the right side of the heatmap."))
}
#Check annotations groups and palettes matching
check.annotations(data = m, annot.grps = annot.grps, annot.pal = annot.pal,
verbose = verbose)
#Handle NAs
if(verbose){ cat("Managing missing values...") }
m <- manage.na(
data = m, method = na.handle, groups = imputation.grps, ncores = ncores)
if(verbose){ cat("Done.\n") }
#Apply ranking function if any function defined
if(verbose){ cat("Ranking data by rows...") }
if(!is.null(rank.fun)){
#TODO: improve this part to support more function with eval() & parse()
m <- m[order(apply(m, 1, sd, na.rm = T), decreasing = TRUE), , drop = FALSE]
}
if(verbose){ cat("Done.\n") }
#Subset top rows if any value defined
if(!is.null(top.rows)){ m <- head(x = m, n = top.rows) }
#Remove NAs if some for dendrogram matrix
if(method.rows != 'none' | method.cols != 'none'){
if(verbose){ cat("Clustering data...") }
dend_mat <- m[complete.cases(m), ]
if(nrow(dend_mat) != nrow(m)){
warning(paste("Distance method selected need complete data.",
nrow(m) - nrow(dend_mat), "incomplete rows removed out of",
nrow(m), "rows selected."))
}
#Check how many rows dend_mat has
if(nrow(dend_mat) == 0){
stop("Cannot compute distances on rows. All rows are missing values.")
}
}
#Compute rows distances & create rows dendrogram
if(method.rows != 'none'){
row_dist <- tryCatch(
parallelDist::parDist(dend_mat, method = method.rows, threads = ncores),
error = function(cond){
if(
grepl(pattern = "impossible d'allouer un vecteur de taille", x = cond)
| grepl(pattern = "cannot allocate vector of size", x = cond)){
cond$message <- paste("Cannot compute distances on rows.",
"Too many rows containing too many values.")
stop(cond) } else { stop(cond) }
}, warning = function(cond){ warning(cond$message) }, finally = {})
row_hclust <- fastcluster::hclust(row_dist)
rm(row_dist)
rowclust <- as.dendrogram(row_hclust)
row.order <- order.dendrogram(rowclust)
if(dd.rows){
#Get dendrogram segments and order matrix rows
ddgr_seg_row <- ggdend(df = ggdendro::dendro_data(rowclust)$segments,
orientation = "left", reverse.x = TRUE)
}
} else if(dd.rows & method.rows == 'none'){
stop(paste("Cannot plot dendrogram on rows with method.rows = 'none'. To",
"avoid this error message, set 'dendrograms' to FALSE."))
}
#Compute columns distances & create columns dendrogram
if(method.cols != 'none'){
ddgr <- as.dendrogram(fastcluster::hclust(parallelDist::parDist(
t(dend_mat), method = method.cols, threads = ncores)))
column.order <- order.dendrogram(ddgr)
if(dd.cols){
#Get dendrogram data
ddgr_dat <- ggdendro::dendro_data(ddgr)
#Get dendrogram segments and order matrix columns
ddgr_seg_col <- ggdend(df = ddgr_dat$segments, orientation = "top")
}
} else if(dd.cols & method.cols == 'none'){
stop("Cannot plot dendrogram on columns with method.cols = 'none'.")
}
#Reorder rows and columns matrix following dendrograms orders
if(method.rows != 'none' & method.cols != 'none'){
# Keep rows selected for the method applied on rows
m <- m[row_hclust$labels, ]
# All dendrograms on and all methods specified
dframe <- m[row.order, column.order, drop = FALSE]
} else if(method.rows != 'none' & is.null(rank.fun) & method.cols == 'none'){
# Keep rows selected for the method applied on rows
m <- m[row_hclust$labels, ]
# row.dendrogram on, col.dendrogram off, method.row specified
dframe <- m[row.order, , drop = FALSE]
} else if(method.rows == 'none' & method.cols != 'none'){
# row.dendrogram off, col.dendrogram on, method.col specified
dframe <- m[, column.order, drop = FALSE]
} else { #Leave matrix unchanged
dframe <- m
}
rm(m)
if(method.rows != 'none' | method.cols != 'none'){
if(verbose){ cat("Done.\n") }
}
#Melt Matrix into a data.table
if(verbose){ cat("Melting matrix...") }
dt.frame <- as.data.table(x = dframe, keep.rownames = TRUE)
dt.frame[, rn := factor(x = rn, levels = rev(rn))]
# dt.frame[, rn := factor(x = rn, levels = rownames(dframe))]
melted_mat <- melt.data.table(
data = dt.frame, id.vars = "rn", measure.vars = colnames(dt.frame)[-c(1)])
if(!is.null(facet)){
dt.facet <- data.table("variable" = colnames(dt.frame)[-c(1)],
"facet.annot" = annot.grps[[facet]])
melted_mat <- merge(
x = melted_mat, y = dt.facet, by = "variable", all.x = TRUE, sort = FALSE)
}
rm(dt.frame)
if(verbose){ cat("Done.\n") }
if(verbose){ cat("Configure heatmap...") }
#Create theme_heatmap
theme_heatmap <- theme(
plot.margin = margin(0, 0, 0, 0), panel.grid = element_blank(),
panel.background = element_rect(fill = "transparent"),
plot.background = element_rect(fill = "transparent"),
legend.text = element_text(size = 11),
legend.title = element_text(size = 12), legend.position = "bottom",
legend.justification = c(0.4, 0.5), axis.title.x = axis.title.x,
axis.text.x = axis.text.x, axis.ticks.x = axis.ticks.x,
axis.title.y.right = axis.title.y.right,
axis.ticks.y.right = axis.ticks.y.right,
axis.text.y.right = axis.text.y.right)
#Set heatmap source parameters
htmp.source <- ggplot() +
scale_fill_gradientn(colours = heatmap.pal, na.value = na.col) +
scale_color_manual(values = NA) +
scale_x_discrete(expand = c(0, 0)) +
guides(fill = guide_colorbar(
ticks = TRUE, label = TRUE, barwidth = 15, ticks.linewidth = 1,
title.vjust = 0.86, order = 1)) +
guides(color = guide_legend(
"NA", override.aes = list(fill = na.col), title.vjust = 0.5, order = 2)) +
labs(x = x.lab, y = y.lab, fill = lgd.scale.name)
#If facetting is on
if(!is.null(facet)){
htmp <- htmp.source +
facet_grid(. ~ facet.annot, scales = "free", space = "free") +
theme(panel.spacing = unit(0, "lines"),
strip.background = element_blank(),
strip.text = element_blank())
} else { htmp <- htmp.source }
#Display legend of missing values if any
if(nrow(melted_mat[is.na(value)]) != 0){
htmp <- htmp + geom_tile(
data = melted_mat, aes(x = variable, y = rn, fill = value, color = " "))
} else {
htmp <- htmp + geom_tile(
data = melted_mat, aes(x = variable, y = rn, fill = value))
}
if(dd.rows){
# htmp <- htmp +
theme_heatmap <- theme_heatmap +
theme(axis.title.y.left = element_blank(),
axis.ticks.y.left = element_blank(),
axis.ticks.length.y.left = unit(0, "pt"),
axis.text.y.left = element_blank(),
plot.margin = unit(c(0, 0, 0, 0), "cm"))
} else {
# htmp <- htmp +
theme_heatmap <- theme_heatmap +
theme(axis.title.y.left = axis.title.y.left,
axis.ticks.y.left = axis.ticks.y.left,
axis.text.y.left = axis.text.y.left,
plot.margin = unit(c(0, 0, 0, 0), "cm"))
}
if(y.axis.right){
htmp <- htmp + scale_y_discrete(position = 'right', expand = c(0, 0))
} else { htmp <- htmp + scale_y_discrete(expand = c(0, 0)) }
if(verbose){ cat("Done.\n") }
if(verbose){ cat("Configure annotations...") }
#Reoder groups and convert as factors
annot.grps <- lapply(X = annot.grps, FUN = function(i){
factor(x = i, levels =  unique(i))})
#If the distance method used on columns is not "none" reorder columns
if(method.cols != "none"){
annot.grps <- lapply(X = annot.grps, FUN = function(i){ i[column.order] })
}
#Set number of columns to display annotations legends
if(lgd.merge){
origin.grps <- lapply(X = annot.grps, FUN = function(i){
if(is.factor(i)){ levels(i) } else { levels(as.factor(i)) }
})
if(is.list(annot.pal)){
if(length(origin.grps) == length(annot.pal)){
ls.df.grp.pal <- Map(
data.frame, "Grps" = origin.grps, "Cols" = annot.pal,
stringsAsFactors = FALSE)
} else {
stop("The number of annotations does not match the number of palettes provided.")
}
} else if(is.vector(annot.pal)){
ls.df.grp.pal <- lapply(X = origin.grps, FUN = function(grp){
data.frame("Grps" = grp, "Cols" = annot.pal, stringsAsFactors = FALSE)
})
}
#Rbind list color tables
col_table <- rbindlist(ls.df.grp.pal, idcol = TRUE)
if(is.vector(annot.pal) | length(annot.pal) == 1){
#Remove duplicated colors
col_table <- col_table[!duplicated(x = Cols)]
}
#Calculate legend length
lgdsizes <- nrow(col_table) + 1
} else {
#Calculate legend length
lgdsizes <- lapply(X = annot.grps, FUN = function(i){ length(unique(i)) })
lgdsizes <- sum(unlist(lgdsizes)) + length(lgdsizes)
}
#Calculate legend columns
lgd.ncol <- ceiling(lgdsizes/30)
#Get ordered sample names
if(method.cols != "none"){ sample.names <- colnames(dframe)
} else { sample.names <- colnames(dframe) }
#Create Color Sidebar
col_sidebar <- plot.col.sidebar(
sample.names = sample.names, annot.grps = annot.grps,
annot.pal = annot.pal, annot.pos = 'top', annot.sep = annot.sep,
annot.cut = annot.cut, cor.order = seq_along(colnames(dframe)),
merge.lgd = lgd.merge, right = TRUE, lgd.name = lgd.bars.name,
lgd.title = lgd.title, lgd.text = lgd.text, lgd.ncol = lgd.ncol,
axis.text.x = element_blank(),
axis.text.y = element_text(size = 12, color = "black"),
axis.ticks.y = element_blank(), axis.ticks.x = element_blank(),
axis.title.x = element_blank(), axis.title.y = element_blank(),
set.x.title = NULL, set.y.title = NULL, dendro.pos = 'top', facet = facet)
if(verbose){ cat("Done.\n") }
#Extract Legend
if(verbose){ cat("Extracting legends...") }
#Create a subsetted plot of the original heatmap
xtrm.melted_mat <- melted_mat[
value %in% c(min(value, na.rm = TRUE), max(value, na.rm = TRUE))]
if(nrow(melted_mat[is.na(value)]) != 0){
subplot.htmp <- htmp.source +
geom_tile(data = xtrm.melted_mat,
aes(x = variable, y = rn, fill = value, color = " "))
} else {
subplot.htmp <- htmp.source +
geom_tile(data = xtrm.melted_mat, aes(x = variable, y = rn, fill = value))
}
htmp_legend <- get.lgd(gg2.obj = subplot.htmp + theme_heatmap)
sidebar_legend <- col_sidebar$legends
#Convert ggplots into grobs
if(dd.cols){ ddgr_seg_col <- ggplotGrob(ddgr_seg_col) }
if(dd.rows){ ddgr_seg_row <- ggplotGrob(ddgr_seg_row) }
col_sidebar_grob <- ggplotGrob(col_sidebar$sidebar)
htmp <- htmp + theme_heatmap + theme(legend.position = "none")
if(verbose){ cat("Done.\n") }
#Heatmap rasterization
if(!is.null(raster)){
if(verbose){ cat("Rasterizing...\n") }
if(raster %in% magick::filter_types()){
#Create "empty" theme
theme_empty <- theme(
plot.margin = margin(0, 0, 0, 0), panel.grid = element_blank(),
panel.background = element_rect(fill = "transparent"),
plot.background = element_rect(fill = "transparent"),
axis.title.x = element_blank(), axis.text.x = element_blank(),
axis.ticks.x = element_blank(), axis.title.y.right = element_blank(),
axis.ticks.y.right = element_blank(),
axis.text.y.right = element_blank(),
axis.title.y.left = element_blank(),
axis.ticks.y.left = element_blank(), axis.text.y.left = element_blank(),
axis.ticks.length = unit(0, "pt"))
#If facet is used
if(!is.null(facet)){
if(verbose){ cat("Facet rasterization:\n") }
ls.rasters <- lapply(
X = levels(melted_mat$facet.annot), FUN = function(i){
if(verbose){ cat(paste("\t", i, "\n")) }
#Create sub DT
sub.melted <- melted_mat[facet.annot == i]
#Create sub heatmap and remove all customization
sub.htmp <- ggplot() +
geom_tile(data = sub.melted,
aes(x = variable, y = rn, fill = value, color = " ")) +
scale_fill_gradientn(colours = heatmap.pal, na.value = na.col) +
scale_color_manual(values = NA) +
scale_x_discrete(expand = c(0, 0)) +
scale_y_discrete(expand = c(0, 0)) +
guides(fill = guide_colorbar(
ticks = TRUE, label = TRUE, barwidth = 15, ticks.linewidth = 1,
title.vjust = 0.86, order = 1)) +
guides(color = guide_legend(
"NA", override.aes = list(fill = na.col), title.vjust = 0.5,
order = 2)) +
labs(x = x.lab, y = y.lab, fill = lgd.scale.name) + theme_empty +
theme(legend.position = "none")
rm(sub.melted)
#Rasterize ggplot into a grob
raster.grob <- raster.ggplot.to.grob(
gg.plot = sub.htmp, filter = raster)
rm(sub.htmp)
#Make grob annotation
raster.annot <- annotation_custom2(
grob = raster.grob, xmin = -Inf, xmax = Inf, ymin = -Inf,
ymax = Inf, data = melted_mat[facet.annot == i])
rm(raster.grob)
return(raster.annot)
})
#Fit the list of raster grobs into a ggplot
htmp <- ggplot(
data = melted_mat, aes(x = variable, y = rn, fill = value)) +
geom_blank() + theme_heatmap + theme(legend.position = "none") +
labs(x = x.lab, y = y.lab) +
facet_grid(. ~ facet.annot, scales = "free", space = "free") +
theme(
panel.spacing = unit(0, "lines"),
strip.background = element_blank(), strip.text = element_blank()) +
ls.rasters
} else {
#Remove all customization
htmp <- htmp + theme_empty
#Catch heatmap in magick::image_graph()
raster.annot <- raster.ggplot.to.grob(gg.plot = htmp, filter = raster)
# fig <- magick::image_graph(width = 2160, height = 2160, res = 96)
# print(htmp)
# dev.off()
# rastered <- magick::image_resize(
#   image = fig, geometry = "1080x1080", filter = raster)
# #Create raster grob
# raster.grob <- grid::rasterGrob(
#   rastered, width = unit(1, "npc"), height = unit(1, "npc"),
#   interpolate = TRUE)
#Make grob annotation
raster.annot <- ggplot2::annotation_custom(
raster.grob, -Inf, Inf, -Inf, Inf)
#Fit the raster grob into a ggplot
htmp <- ggplot(
data = melted_mat, aes(x = variable, y = rn, fill = value)) +
geom_blank() + raster.annot + theme_heatmap +
theme(legend.position = "none") + labs(x = x.lab, y = y.lab)
}
} else { stop("Rasterization filter not supported.") }
if(verbose){ cat("Done.\n") }
}
htmp <- ggplotGrob(x = htmp)
#Resize grobs
if(dd.cols & dd.rows){
ls.w.grobs <- list(
'dd_col' = ddgr_seg_col, 'sidebar' = col_sidebar_grob, 'htmp' = htmp)
upd.grob_w <- resize.grobs(ls.grobs = ls.w.grobs, dimensions = "widths",
start.unit = 4, end.unit = 7)
} else if(dd.cols & !dd.rows){
ls.w.grobs <- list(
'dd_col' = ddgr_seg_col, 'sidebar' = col_sidebar_grob, 'htmp' = htmp)
upd.grob_w <- resize.grobs(ls.grobs = ls.w.grobs, dimensions = "widths",
start.unit = 3, end.unit = 7)
} else {
ls.w.grobs <- list('sidebar' = col_sidebar_grob, 'htmp' = htmp)
if(is.null(facet)){
upd.grob_w <- resize.grobs(ls.grobs = ls.w.grobs, dimensions = "widths",
start.unit = 3, end.unit = 7)
} else {
upd.grob_w <- resize.grobs(ls.grobs = ls.w.grobs, dimensions = "widths",
start.unit = 1, end.unit = 55)
}
}
if(dd.rows){
ls.h.grobs <- list('dd_row' = ddgr_seg_row, 'htmp' = upd.grob_w$htmp)
upd.grob_h <- resize.grobs(ls.grobs = ls.h.grobs, dimensions = 'heights',
start.unit = 7, end.unit = 9)
} else { upd.grob_h <- list("htmp" = upd.grob_w$htmp) }
#Create the Right Panel for legends
sidebar_legend.grob <- stack.grobs.legends(
grobs.list = sidebar_legend, annot.grps = annot.grps,
height.lgds.space = 29)
right.legends <- sidebar_legend.grob
#Combine Dendrogram with Color Sidebar and Heatmap
if(dd.rows & dd.cols){
#Create main grob
main_grob <- gridExtra::arrangeGrob(
grobs = list(grid::textGrob(""), upd.grob_w$dd_col,
grid::textGrob(""), upd.grob_w$sidebar,
upd.grob_h$dd_row, upd.grob_h$htmp),
ncol = 2, nrow = 3, heights = c(dend.col.size + 2, annot.size, 30),
widths = c(dend.row.size + 1, 10))
#Set default legend width space
def.lgd.width <- 2
} else if(!dd.rows & !dd.cols){
#Create main grob
main_grob <- gridExtra::arrangeGrob(grobs = list(
upd.grob_w$sidebar, upd.grob_h$htmp), ncol = 1, nrow = 2,
heights = c(annot.size, 30), widths = 10)
#Set default legend width space
def.lgd.width <- 1
} else if(dd.rows & !dd.cols){
#Create main grob
main_grob <- gridExtra::arrangeGrob(grobs = list(
grid::textGrob(""), upd.grob_w$sidebar, upd.grob_h$dd_row,
upd.grob_h$htmp), ncol = 2, nrow = 2, heights = c(annot.size, 30),
widths = c(dend.row.size + 1, 10))
#Set default legend width space
def.lgd.width <- 2
} else if(!dd.rows & dd.cols){
#Create main grob
main_grob <- gridExtra::arrangeGrob(grobs = list(
upd.grob_w$dd_col, upd.grob_w$sidebar, upd.grob_h$htmp), ncol = 1,
nrow = 3, heights = c(dend.col.size + 2, annot.size, 30), widths = 10)
#Set default legend width space
def.lgd.width <- 1
}
#Final plot
final.plot <- gridExtra::grid.arrange(gridExtra::arrangeGrob(
top = grid::textGrob(
plot.title, gp = grid::gpar(fontsize = 15, font = 1)),
grobs = list(grid::textGrob(paste0(
"Columns ordered by ", method.cols, " distance; Rows ordered by ",
method.rows, " distance; ", nrow(dframe), " ", row.type, "."),
gp = grid::gpar(fontsize = 12, fontface = 3L)),
gridExtra::arrangeGrob(grobs = list(main_grob, right.legends), ncol = 2,
widths = c(20, def.lgd.width + lgd.space.width)),
htmp_legend), nrow = 3, heights = c(3, 50, 6)))
#Return the gtable of the heatmap
return(final.plot)
}
facet_meth_heatmap <- gg2heatmap(
m = miss.sesame.cg.beta.mat, na.handle = "keep", raster = "Lanczos",
rank.fun = "sd", ncores = 13, dist.method = "none", dendrograms = FALSE,
lgd.space.width = 2, annot.grps = list("Chromosomes" = chromosomes),
annot.pal = rainbow(n = 24), annot.size = 3, axis.text.x = element_blank(),
axis.ticks.x = element_blank(), axis.title.y.left = element_text(size = 12),
plot.title = "PCAWG missing methylation data distribution",
row.type = "CG probes", x.lab = "CG probes", y.lab = "Samples",
lgd.scale.name = "Methylation", facet = "Chromosomes", verbose = TRUE)
getwd()
ggsave(filename = "PCAWG_Paper/graphs/PCAWG_incomplete_data.pdf",
plot = facet_meth_heatmap, device = "pdf", width = 10, height = 10)
ggsave(filename = "PCAWG_Paper/graphs/PCAWG_incomplete_data.pdf",
plot = facet_meth_heatmap, device = "pdf", width = 15, height = 10)
ggsave(filename = "PCAWG_Paper/graphs/PCAWG_incomplete_data.pdf",
plot = facet_meth_heatmap, device = "pdf", width = 20, height = 10)
ggsave(filename = "PCAWG_Paper/graphs/PCAWG_incomplete_data.png",
plot = facet_meth_heatmap, device = "png", width = 20, height = 10)
facet_meth_heatmap$layout
facet_meth_heatmap$widths
facet_meth_heatmap$heights
dim(miss.sesame.cg.beta.mat)
devtools::document()
setwd("/home/yoann/BiocompR/")
devtools::document()
devtools::install()
